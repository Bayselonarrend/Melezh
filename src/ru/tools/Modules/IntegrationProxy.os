// MIT License

// Copyright (c) 2025 Anton Tsitavets

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/Bayselonarrend/OpenIntegrations

// BSLLS:Typo-off
// BSLLS:LatinAndCyrillicSymbolInWord-off
// BSLLS:IncorrectLineBreak-off
// BSLLS:NumberOfOptionalParams-off
// BSLLS:UsingServiceTag-off
// BSLLS:LineLength-off

//@skip-check module-structure-top-region
//@skip-check module-structure-method-in-regions
//@skip-check wrong-string-literal-content
//@skip-check method-too-many-params
//@skip-check constructor-function-return-section

// Раскомментировать, если выполняется OneScript
#Использовать oint
#Использовать oint-cli
#Использовать "./internal"
#Использовать "../../env"
#Использовать "../../env/cronos/core"


#Область ПрограммныйИнтерфейс

#Область НастройкаПроектов

// Создать проект
// Создает файл проекта по выбранному пути
//
// Параметры:
//  Путь - Строка  - Путь к файлу проекта - path
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат создания
Функция СоздатьПроект(Знач Путь) Экспорт

    Возврат НормализоватьПроект(Путь);

КонецФункции

// Запустить проект
// Запускает прокси сервер интеграций
//
// Параметры:
//  Порт        - Число  - Порт запуска сервера - port
//  Проект      - Строка - Путь к файлу проекта - proj
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат остановки сервера
Функция ЗапуститьПроект(Знач Порт, Знач Проект) Экспорт

    Если Не OPI_Инструменты.ЭтоOneScript() Тогда
        МенеджерФоновыхЗаданий = Неопределено;
        ВызватьИсключение "Данная функция доступна для вызова только в OneScript!";
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьЧисло(Порт);

    Проверка = ПроверитьВосстановитьПроект(Проект);

    Если Не Проверка["result"] Тогда
        Возврат Проверка;
    КонецЕсли;

    СтруктураИнициализации = ПолучитьСтруктуруИнициализацииМеханизмов(Проект);

    МенеджерФоновыхЗаданий = Новый("МенеджерФоновыхЗаданий");
    МассивФоновыхЗаданий   = Новый Массив;
    МассивОписанийЗаданий  = Новый Массив;

    // Веб-сервер

    МассивПараметров = Новый Массив;
    МассивПараметров.Добавить(Проект);
    МассивПараметров.Добавить(Порт);
    МассивПараметров.Добавить(СтруктураИнициализации);

    ИмяМетода = "ЗапуститьВебСервер";

    МассивОписанийЗаданий.Добавить(Новый Структура("Метод,Параметры", ИмяМетода, МассивПараметров));

    // Планировщик

    МассивПараметров = Новый Массив;
    МассивПараметров.Добавить(Проект);
    МассивПараметров.Добавить(СтруктураИнициализации);

    ИмяМетода = "ЗапуститьМенеджерРегламентныхЗаданий";

    МассивОписанийЗаданий.Добавить(Новый Структура("Метод,Параметры", ИмяМетода, МассивПараметров));

    // Запуск

    Для Каждого ОписаниеЗадания Из МассивОписанийЗаданий Цикл

        НовоеЗадание = МенеджерФоновыхЗаданий.Выполнить(ЭтотОбъект, ОписаниеЗадания["Метод"], ОписаниеЗадания["Параметры"], Истина);
        МассивФоновыхЗаданий.Добавить(НовоеЗадание);

    КонецЦикла;

    Пока Истина Цикл

        УпавшееЗадание = МенеджерФоновыхЗаданий.ОжидатьЛюбое(МассивФоновыхЗаданий);
        ОбъектЗадания  = МассивФоновыхЗаданий[УпавшееЗадание];

        Попытка
            Ошибка = ПодробноеПредставлениеОшибки((ОбъектЗадания.ИнформацияОбОшибке));
        Исключение
            Ошибка = "";
        КонецПопытки;

        Сообщить(СтрШаблон("Критическая ошибка в задании %1: %2 Перезапуск...", УпавшееЗадание, Ошибка));

        Приостановить(2000);

        ОписаниеЗадания = МассивОписанийЗаданий[УпавшееЗадание];

        НовоеЗадание = МенеджерФоновыхЗаданий.Выполнить(ЭтотОбъект, ОписаниеЗадания["Метод"], ОписаниеЗадания["Параметры"], Истина);
        МассивФоновыхЗаданий.Установить(УпавшееЗадание, НовоеЗадание);

    КонецЦикла;

    Возврат СформироватьОтвет(Истина, "Stopped");

КонецФункции

// Получить настройки проекта
// Получает список всех текущих настроек проекта
//
// Параметры:
//  Проект - Строка  - Путь к файлу проекта - proj
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Список настроек проекта
Функция ПолучитьНастройкиПроекта(Знач Проект) Экспорт

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Таблица   = КонстантноеЗначение("ТаблицаНастроек");
    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , , , , Проект);

    Если Результат["result"] Тогда

        ОпределениеНастроек = Неопределено;

        ОТЧ = Новый ОписаниеТипов("Число");
        ОТБ = Новый ОписаниеТипов("Булево");

        Для Каждого ЧастьНастроек Из Результат["data"] Цикл

            ТипДанных = ЧастьНастроек["type"];

            Если Не ЗначениеЗаполнено(ТипДанных) Тогда

                Если Не ЗначениеЗаполнено(ОпределениеНастроек) Тогда
                    ОпределениеНастроек = ПолучитьСтандартныеНастройки();
                КонецЕсли;

                ТекущееОпределение = ОпределениеНастроек.Получить(ЧастьНастроек["name"]);

                Если ЗначениеЗаполнено(ТекущееОпределение) Тогда
                    ТипДанных = ТекущееОпределение["type"];
                КонецЕсли;

            КонецЕсли;

            Если ТипДанных = "bool" Тогда

                ТекущееЗначение = ЧастьНастроек["value"];

                Если ТипЗнч(ТекущееЗначение) = Тип("Строка") Тогда
                
                    ЧастьНастроек["value"] = ?(ТекущееЗначение = "0", 0, ТекущееЗначение);
                    ЧастьНастроек["value"] = ?(ТекущееЗначение = "1", 1, ТекущееЗначение);

                КонецЕсли;

                ЧастьНастроек["value"] = ОТБ.ПривестиЗначение(ЧастьНастроек["value"]);

            ИначеЕсли ТипДанных = "number" Тогда
                ЧастьНастроек["value"] = ОТЧ.ПривестиЗначение(ЧастьНастроек["value"]);
            Иначе
                ЧастьНастроек["value"] = Строка(ЧастьНастроек["value"]);
            КонецЕсли;

        КонецЦикла;

    КонецЕсли;

    Возврат Результат;

КонецФункции

// Заполнить настройки проекта
// Заполняет настройки из переданной коллекции
//
// Примечание:
// Если значения устанавливаются в уже запущенном проекте, то они может вступить в силу с задержкой до 60 секунд
//
// Параметры:
//  Проект    - Строка                        - Путь к файлу проекта                              - proj
//  Настройки - Соответствие Из КлючИЗначение - Коллекция ключ и значение для заполнения настроек - set
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Список настроек проекта
Функция ЗаполнитьНастройкиПроекта(Знач Проект, Знач Настройки) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Проект);
    OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Настройки);

    Результат        = ПроверитьСуществованиеПроекта(Проект);
    Таблица          = КонстантноеЗначение("ТаблицаНастроек");
    ТекущиеНастройки = OPI_SQLite.ПолучитьЗаписи(Таблица, , , , , Проект);

    Если Не ТекущиеНастройки["result"] Тогда
        Возврат ТекущиеНастройки;
    Иначе
        ТекущиеНастройки = ТекущиеНастройки["data"];
    КонецЕсли;

    Для Каждого Настройка Из ТекущиеНастройки Цикл

        ТекущееЗначение = Настройка["value"];
        ТекущийТип      = Настройка["type"];

        Если OPI_Инструменты.ПолеКоллекцииСуществует(Настройки, Настройка["name"], ТекущееЗначение) Тогда

            Если ТекущийТип = "bool" Тогда

                OPI_ПреобразованиеТипов.ПолучитьБулево(ТекущееЗначение);
                Настройка["value"] = ?(ТекущееЗначение, "true", "false");

            ИначеЕсли ТекущийТип = "number" Тогда
                
                OPI_ПреобразованиеТипов.ПолучитьЧисло(ТекущееЗначение);
                Настройка["value"] = Строка(ТекущееЗначение);

            Иначе
                Настройка["value"] = Строка(ТекущееЗначение);
            КонецЕсли;

        КонецЕсли;

    КонецЦикла;

    Таблица    = КонстантноеЗначение("ТаблицаНастроек");
    Соединение = OPI_SQLite.ОткрытьСоединение(Проект);

    Результат = OPI_SQLite.ОчиститьТаблицу(Таблица, Соединение);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    КонецЕсли;

    Результат = OPI_SQLite.ДобавитьЗаписи(Таблица, ТекущиеНастройки, , Соединение);

    Если Результат["result"] Тогда
        Возврат Новый Структура("result", Истина);
    Иначе
        Возврат Результат;
    КонецЕсли;

КонецФункции

// Установить настройку проекта
// Устанавливает значение выбранной настройки проекта
//
// Примечание:
// Если значение изменяется в уже запущенном проекте, то оно может вступить в силу с задержкой до 60 секунд
//
// Параметры:
//  Проект    - Строка - Путь к файлу проекта       - proj
//  Настройка - Строка - Ключ настройки проекта     - key
//  Значение  - Строка - Значение настройки проекта - value
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат установки
Функция УстановитьНастройкуПроекта(Знач Проект, Знач Настройка, Знач Значение) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Настройка);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);

    Возврат ЗаполнитьНастройкиПроекта(Проект, Новый Структура(Настройка, Значение));

КонецФункции

// Сменить пароль UI
// Изменяет пароль для входа в веб-консоль
//
// Примечание:
// Если значение изменяется в уже запущенном проекте, то оно может вступить в силу с задержкой до 60 секунд
//
// Параметры:
//  Проект - Строка - Путь к файлу проекта  - proj
//  Пароль - Строка - Новый пароль          - pass
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат смены пароля
Функция СменитьПарольUI(Знач Проект, Знач Пароль) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Пароль);
    Возврат УстановитьНастройкуПроекта(Проект, "ui_password", Пароль);

КонецФункции

#КонецОбласти

#Область НастройкаОбработчиков

// Добавить обработчик запросов
// Добавляет новый обработчик в проект
//
// Параметры:
//  Проект        - Строка - Путь к файлу проекта                                               - proj
//  БиблиотекаОПИ - Строка - Имя библиотеки в CLI формате                                       - lib
//  ФункцияОПИ    - Строка - Имя функции Открытого пакета интеграций                            - func
//  Метод         - Строка - HTTP метод, который будет обрабатывать обработчик: GET, JSON, FORM - method
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат добавления обработчика
Функция ДобавитьОбработчикЗапросов(Знач Проект, Знач БиблиотекаОПИ, Знач ФункцияОПИ, Знач Метод = "GET") Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(БиблиотекаОПИ);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(ФункцияОПИ);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);

    Метод     = вРег(Метод);
    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Если Не Метод = "GET" И Не Метод = "JSON" И Не Метод = "FORM" Тогда
        Возврат СформироватьОтвет(Ложь, СтрШаблон("Неподдерживаемый метод %1!", Метод));
    КонецЕсли;

    СекретныйКлюч = ПолучитьУникальныйКлючОбработчика(Проект);

    Если ТипЗнч(СекретныйКлюч) = Тип("Соответствие") Тогда
        СекретныйКлюч.Вставить("message", "Не удалось сформировать UID обработчика. Попробуйте еще раз!");
        Возврат СекретныйКлюч;
    КонецЕсли;

    СтруктураЗаписи = Новый Структура;
    СтруктураЗаписи.Вставить("library" , БиблиотекаОПИ);
    СтруктураЗаписи.Вставить("function", ФункцияОПИ);
    СтруктураЗаписи.Вставить("key"     , СекретныйКлюч);
    СтруктураЗаписи.Вставить("method"  , Метод);
    СтруктураЗаписи.Вставить("active"  , Истина);

    ИмяТаблицыОбработчиков = КонстантноеЗначение("ТаблицаОбработчиков");
    Результат              = OPI_SQLite.ДобавитьЗаписи(ИмяТаблицыОбработчиков, СтруктураЗаписи, Ложь, Проект);

    Если Результат["result"] Тогда

          Результат = Новый Структура;
          Результат.Вставить("result"     , Истина);
          Результат.Вставить("key"        , СекретныйКлюч);
          Результат.Вставить("url_example", "localhost:port/" + СекретныйКлюч);

    КонецЕсли;

    Возврат Результат;

КонецФункции

// Получить список обработчиков запросов
// Получает список обработчиков в проекте
//
// Параметры:
//  Проект - Строка  - Путь к файлу проекта - proj
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Список обработчиков
Функция ПолучитьСписокОбработчиковЗапросов(Знач Проект) Экспорт

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Таблица   = КонстантноеЗначение("ТаблицаОбработчиков");
    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , , , , Проект);

    Возврат Результат;

КонецФункции

// Получить обработчик запросов
// Получает информацию об обработчике по ключу
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта - proj
//  КлючОбработчика - Строка - Ключ обработчика     - handler
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Информация об обработчике
Функция ПолучитьОбработчикЗапросов(Знач Проект, Знач КлючОбработчика) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Таблица = КонстантноеЗначение("ТаблицаОбработчиков");

    СтруктураФильтра = Новый Структура;

    СтруктураФильтра.Вставить("field", "key");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", КлючОбработчика);
    СтруктураФильтра.Вставить("raw"  , Ложь);

    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , СтруктураФильтра, , , Проект);

    Если Результат["result"] Тогда

        Для Каждого Элемент Из Результат["data"] Цикл

            Аргументы = ПолучитьАргументыОбработчика(Проект, КлючОбработчика);
            Аргументы = ?(Аргументы["result"], Аргументы["data"], Аргументы);

            Элемент.Вставить("args", Аргументы);

        КонецЦикла;

        КоличествоЗаписей = Результат["data"].Количество();

        Если КоличествоЗаписей = 1 Тогда

            Результат["data"] = Результат["data"][0];

        Иначе

            Если КоличествоЗаписей = 0 Тогда
                Результат = СформироватьОтвет(Ложь, "Обработчик не найден!");
             КонецЕсли;

        КонецЕсли;

    КонецЕсли;

    Возврат Результат;

КонецФункции

// Удалить обработчик запросов
// Удаляет обработчик запросов из проекта
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта - proj
//  КлючОбработчика - Строка - Ключ обработчика     - handler
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат удаления
Функция УдалитьОбработчикЗапросов(Знач Проект, Знач КлючОбработчика) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    СтруктураФильтра = Новый Структура;

    СтруктураФильтра.Вставить("field", "key");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", КлючОбработчика);
    СтруктураФильтра.Вставить("raw"  , Ложь);

    Результаты = Новый Соответствие;
    Успех      = Истина;

    Для Каждого Таблица Из ИменаКонстантТаблиц() Цикл

        ИмяТаблицы   = КонстантноеЗначение(Таблица);
        Результат    = OPI_SQLite.УдалитьЗаписи(ИмяТаблицы, СтруктураФильтра, Проект);
        ТекущийУспех = Результат["result"];

        Результаты.Вставить(ИмяТаблицы, ТекущийУспех);

        Успех = ?(Не ТекущийУспех, ТекущийУспех, Успех);

    КонецЦикла;

    Возврат Новый Структура("result,tables", Успех, Результаты);

КонецФункции

// Изменить обработчик запросов
// Изменяет значения полей обработчика запросов
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта                                               - proj
//  КлючОбработчика - Строка - Ключ обработчика                                                   - handler
//  БиблиотекаОПИ   - Строка - Имя библиотеки в CLI формате                                       - lib
//  ФункцияОПИ      - Строка - Имя функции Открытого пакета интеграций                            - func
//  Метод           - Строка - HTTP метод, который будет обрабатывать обработчик: GET, JSON, FORM - method
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат изменения обработчика
Функция ИзменитьОбработчикЗапросов(Знач Проект
    , Знач КлючОбработчика
    , Знач БиблиотекаОПИ = ""
    , Знач ФункцияОПИ = ""
    , Знач Метод = "") Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(БиблиотекаОПИ);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(ФункцияОПИ);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    СтруктураЗаписи = Новый Структура;

    Если ЗначениеЗаполнено(БиблиотекаОПИ) Тогда
        СтруктураЗаписи.Вставить("library" , БиблиотекаОПИ);
    КонецЕсли;

    Если ЗначениеЗаполнено(ФункцияОПИ) Тогда
        СтруктураЗаписи.Вставить("function", ФункцияОПИ);
    КонецЕсли;

    Если ЗначениеЗаполнено(Метод) Тогда
        СтруктураЗаписи.Вставить("method"  , Метод);
    КонецЕсли;

    Результат = ИзменитьПоляОбработчика(Проект, КлючОбработчика, СтруктураЗаписи);

    Возврат Результат;

КонецФункции

// Отключить обработчик запросов
// Отключает обработчик по ключу
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта - proj
//  КлючОбработчика - Строка - Ключ обработчика     - handler
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат переключения
Функция ОтключитьОбработчикЗапросов(Знач Проект, Знач КлючОбработчика) Экспорт

    Возврат ПереключитьОбработчикЗапросов(Проект, КлючОбработчика, Ложь);

КонецФункции

// Включить обработчик запросов
// Включает обработчик по ключу
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта - proj
//  КлючОбработчика - Строка - Ключ обработчика     - handler
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат переключения
Функция ВключитьОбработчикЗапросов(Знач Проект, Знач КлючОбработчика) Экспорт

    Возврат ПереключитьОбработчикЗапросов(Проект, КлючОбработчика, Истина);

КонецФункции

// Обновить ключ обработчика
// Заменяет ключ обработчика на новый
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта                                            - proj
//  КлючОбработчика - Строка - Ключ обработчика                                                - handler
//  НовыйКлюч       - Строка - Свой ключ, если необходимо. Новый стандартный UUID по умолчанию - key
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Информация об обработчике
Функция ОбновитьКлючОбработчика(Знач Проект, Знач КлючОбработчика, Знач НовыйКлюч = "") Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(НовыйКлюч);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    НовыйКлюч = ?(ЗначениеЗаполнено(НовыйКлюч), НовыйКлюч, ПолучитьUUID(9));

    СтруктураЗаписи = Новый Структура("key", НовыйКлюч);
    Результат       = ИзменитьПоляОбработчика(Проект, КлючОбработчика, СтруктураЗаписи);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    КонецЕсли;

    Результат = ПолучитьОбработчикЗапросов(Проект, НовыйКлюч);

    Возврат Результат;

КонецФункции

#КонецОбласти

#Область ОпцииОбработчиков

Функция УстановитьОпциюОбработчика(Знач Проект, Знач КлючОбработчика, Знач Опция, Знач Значение) Экспорт

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Опция);

    МассивФильтров = Новый Массив;

    СтруктураФильтра = Новый Структура;
    СтруктураФильтра.Вставить("field", "key");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", КлючОбработчика);
    СтруктураФильтра.Вставить("raw"  , Ложь);
    МассивФильтров.Добавить(СтруктураФильтра);

    СтруктураФильтра = Новый Структура;
    СтруктураФильтра.Вставить("field", "option");
    СтруктураФильтра.Вставить("value", Опция);
    МассивФильтров.Добавить(СтруктураФильтра);

    Таблица   = КонстантноеЗначение("ТаблицаОпцийОбработчиков");
    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , МассивФильтров, , , Проект);

    Если Результат["result"] Тогда

        КоличествоЗаписей = Результат["data"].Количество();

        СтруктураЗаписи = Новый Структура("value", Значение);

        Если КоличествоЗаписей <> 0 Тогда
            Результат = OPI_SQLite.ОбновитьЗаписи(Таблица, СтруктураЗаписи, МассивФильтров, Проект);
        Иначе
            Результат = Новый Структура("result,error", Ложь, "Опция не найдена!");
        КонецЕсли;

        Если Результат["result"] Тогда
            Результат = ПолучитьОпцииОбработчика(Проект, КлючОбработчика);
        КонецЕсли;

    КонецЕсли;

    Возврат Результат;

КонецФункции

Функция ПолучитьОпцииОбработчика(Знач Проект, Знач КлючОбработчика) Экспорт

КонецФункции

#КонецОбласти

#Область УстановкаАргументов

// Установить аргумент обработчика
// Устанавливает аргумент для функции обработчика, позволяя не указывать его при вызове
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта                                           - proj
//  КлючОбработчика - Строка - Ключ обработчика                                               - handler
//  Аргумент        - Строка - CLI аргумент (опция) для функции обработчика                   - arg
//  Значение        - Строка - Строковое значение аргумента                                   - value
//  Строгий         - Булево - Истина > аргумент не может быть перезаписан данными из запроса - strict
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат установки
Функция УстановитьАргументОбработчика(Знач Проект
    , Знач КлючОбработчика
    , Знач Аргумент
    , Знач Значение
    , Знач Строгий = Истина) Экспорт

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Аргумент);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
    OPI_ПреобразованиеТипов.ПолучитьБулево(Строгий);

    МассивФильтров = Новый Массив;

    СтруктураФильтра = Новый Структура;
    СтруктураФильтра.Вставить("field", "key");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", КлючОбработчика);
    СтруктураФильтра.Вставить("raw"  , Ложь);
    МассивФильтров.Добавить(СтруктураФильтра);

    СтруктураФильтра = Новый Структура;
    СтруктураФильтра.Вставить("field", "arg");
    СтруктураФильтра.Вставить("value", Аргумент);
    МассивФильтров.Добавить(СтруктураФильтра);

    Таблица   = КонстантноеЗначение("ТаблицаАргументов");
    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , МассивФильтров, , , Проект);

    Если Результат["result"] Тогда

        КоличествоЗаписей = Результат["data"].Количество();

        СтруктураЗаписи = Новый Структура("value,strict", Значение, Строгий);

        Если КоличествоЗаписей <> 0 Тогда
            Результат = OPI_SQLite.ОбновитьЗаписи(Таблица, СтруктураЗаписи, МассивФильтров, Проект);
        Иначе

            СтруктураЗаписи.Вставить("key", КлючОбработчика);
            СтруктураЗаписи.Вставить("arg", Аргумент);
            Результат = OPI_SQLite.ДобавитьЗаписи(Таблица, СтруктураЗаписи, Ложь, Проект);

        КонецЕсли;

        Если Результат["result"] Тогда
            Результат = ПолучитьОбработчикЗапросов(Проект, КлючОбработчика);
        КонецЕсли;

    КонецЕсли;

    Возврат Результат;

КонецФункции

// Получить аргументы обработчика
// Получает список установленных аргументов обработчика
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта - proj
//  КлючОбработчика - Строка - Ключ обработчика     - handler
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Список обработчиков
Функция ПолучитьАргументыОбработчика(Знач Проект, Знач КлючОбработчика) Экспорт

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);

    СтруктураФильтра = Новый Структура;
    СтруктураФильтра.Вставить("field", "key");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", КлючОбработчика);
    СтруктураФильтра.Вставить("raw"  , Ложь);

    Таблица     = КонстантноеЗначение("ТаблицаАргументов");
    МассивПолей = СтрРазделить("arg,value,strict", ",");

    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, МассивПолей, СтруктураФильтра, , , Проект);

    Возврат Результат;

КонецФункции

// Очистить аргументы обработчика
// Удаляет все установленные ранее значения аргументов обработчика
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта - proj
//  КлючОбработчика - Строка - Ключ обработчика     - handler
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат очистки
Функция ОчиститьАргументыОбработчика(Знач Проект, Знач КлючОбработчика) Экспорт

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);

    СтруктураФильтра = Новый Структура;
    СтруктураФильтра.Вставить("field", "key");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", КлючОбработчика);
    СтруктураФильтра.Вставить("raw"  , Ложь);

    Таблица = КонстантноеЗначение("ТаблицаАргументов");

    Результат = OPI_SQLite.УдалитьЗаписи(Таблица, СтруктураФильтра, Проект);

    Возврат Результат;

КонецФункции

#КонецОбласти

#Область РегламентныеЗадания

// Добавить регламентное задание
// Добавляет новый обработчик в проект
//
// Примечание:
// Формат расписания:^
// sec  min   hour   day of month   month   day of week   year^
//  0   30   9,12,15     1,15       May-Aug  Mon,Wed,Fri  2018/2
//
// Параметры:
//  Проект          - Строка - Путь к файлу проекта                  - proj
//  КлючОбработчика - Строка - Ключ обработчика                      - handler
//  Расписание      - Строка - Расписание в расширенном cron формате - cron
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат добавления задания
Функция ДобавитьРегламентноеЗадание(Знач Проект, Знач КлючОбработчика, Знач Расписание) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Расписание);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Результат = ПолучитьОбработчикЗапросов(Проект, КлючОбработчика);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    КонецЕсли;

    СтруктураЗаписи = Новый Структура;
    СтруктураЗаписи.Вставить("handler"    , КлючОбработчика);
    СтруктураЗаписи.Вставить("cron"       , Расписание);
    СтруктураЗаписи.Вставить("active"     , Истина);

    ИмяТаблицыОбработчиков = КонстантноеЗначение("ТаблицаЗаданий");
    Соединение             = OPI_SQLite.ОткрытьСоединение(Проект);
    Результат              = OPI_SQLite.ДобавитьЗаписи(ИмяТаблицыОбработчиков, СтруктураЗаписи, Ложь, Соединение);

    Если Результат["result"] Тогда

        IDЗадания = OPI_SQLite.ВыполнитьЗапросSQL("SELECT LAST_INSERT_ROWID();", , , Соединение);

        Если IDЗадания["result"] Тогда
            Результат.Вставить("id", Строка(IDЗадания["data"][0]["LAST_INSERT_ROWID()"]));
        Иначе
            Результат.Вставить("id", "Объект создан, но не удалось получить его ID: " + IDЗадания["error"]);
        КонецЕсли;

    КонецЕсли;

    Возврат Результат;

КонецФункции

// Удалить регламентное задание
// Удаляет регламентное задание из проекта
//
// Параметры:
//  Проект    - Строка - Путь к файлу проекта - proj
//  IDЗадания - Число  - ID задания           - task
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Результат удаления
Функция УдалитьРегламентноеЗадание(Знач Проект, Знач IDЗадания) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(IDЗадания);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Таблица = КонстантноеЗначение("ТаблицаЗаданий");

    СтруктураФильтра = Новый Структура;

    СтруктураФильтра.Вставить("field", "id");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", IDЗадания);
    СтруктураФильтра.Вставить("raw"  , Ложь);

    Результат = OPI_SQLite.УдалитьЗаписи(Таблица, СтруктураФильтра, Проект);

    Возврат Результат;

КонецФункции

// Получить список регламентных заданий
// Получает список регламентных заданий в проекте
//
// Параметры:
//  Проект - Строка  - Путь к файлу проекта - proj
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Список заданий
Функция ПолучитьСписокРегламентныхЗаданий(Знач Проект) Экспорт

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Таблица   = КонстантноеЗначение("ТаблицаЗаданий");
    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , , , , Проект);

    Возврат Результат;

КонецФункции

// Получить регламентное задание
// Получает информацию о задании по ID
//
// Параметры:
//  Проект    - Строка - Путь к файлу проекта - proj
//  IDЗадания - Строка - ID задания           - task
//
// Возвращаемое значение:
//  Структура Из КлючИЗначение - Информация об обработчике
Функция ПолучитьРегламентноеЗадание(Знач Проект, Знач IDЗадания) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(IDЗадания);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    Таблица = КонстантноеЗначение("ТаблицаЗаданий");

    СтруктураФильтра = Новый Структура;

    СтруктураФильтра.Вставить("field", "id");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", IDЗадания);
    СтруктураФильтра.Вставить("raw"  , Ложь);

    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , СтруктураФильтра, , , Проект);

    Если Результат["result"] Тогда

        Если Результат["data"].Количество() = 0 Тогда
            Результат = СформироватьОтвет(Ложь, "Задание не найдено!");
        Иначе
            Результат["data"] = Результат["data"][0];
        КонецЕсли;
        
    КонецЕсли;

    Возврат Результат;

КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ПолучитьУникальныйКлючОбработчика(Путь) Экспорт

    СекретныйКлюч = ПолучитьUUID(9);
    Таблица       = КонстантноеЗначение("ТаблицаОбработчиков");

    СтруктураФильтра = Новый Структура;

    СтруктураФильтра.Вставить("field", "key");
    СтруктураФильтра.Вставить("type" , "=");
    СтруктураФильтра.Вставить("value", СекретныйКлюч);
    СтруктураФильтра.Вставить("raw"  , Ложь);

    Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , СтруктураФильтра, , , Путь);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    КонецЕсли;

    Пока Результат["data"].Количество() > 0 Цикл

        СекретныйКлюч             = ПолучитьUUID(9);
        СтруктураФильтра["value"] = СекретныйКлюч;

        Результат = OPI_SQLite.ПолучитьЗаписи(Таблица, , СтруктураФильтра, , , Путь);

        Если Не Результат["result"] Тогда
            Возврат Результат;
        КонецЕсли;

    КонецЦикла;

    Возврат СекретныйКлюч;

КонецФункции

Процедура ЗапуститьВебСервер(Проект, Порт, СтруктураИнициализации) Экспорт

    ТипСервер = Тип("ВебСервер");

    ПараметрыСервера    = Новый Массив(1);
    ПараметрыСервера[0] = Порт;

    ВебСервер  = Новый(ТипСервер, ПараметрыСервера);

    Обработчик = Новый("RequestsHandler");
    Обработчик.Инициализировать(СтруктураИнициализации);

    ВебСервер.ДобавитьОбработчикЗапросов(Обработчик, "ОсновнаяОбработка");
    ВебСервер.Запустить();

КонецПроцедуры

Процедура ЗапуститьМенеджерРегламентныхЗаданий(Проект, СтруктураИнициализации) Экспорт

    МенеджерРЗ = Новый("ScheduledTasksManager");
    МенеджерРЗ.Инициализировать(СтруктураИнициализации);
    МенеджерРЗ.Запустить();
        
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область Проект

Функция ПроверитьСуществованиеПроекта(Путь)

    Если OPI_Компоненты.ЭтоКомпонента(Путь) Тогда
        Возврат СформироватьОтвет(Истина, "", Путь);
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Путь);
    OPI_Инструменты.ВернутьУправляющиеПоследовательности(Путь);

    ФайлПроекта = Новый Файл(Путь);
    Текст       = "Файл проекта существует!";
    Результат   = Истина;

    Если Не ФайлПроекта.Существует() Тогда
        Текст     = "Файл проекта по указанному пути не найден!";
        Результат = Ложь;
    КонецЕсли;

    Если ФайлПроекта.ЭтоКаталог() Тогда
        Текст     =  "Передан путь к каталогу, а не к файлу проекта!";
        Результат = Ложь;
    КонецЕсли;

    СтруктураОтвета = СформироватьОтвет(Результат, Текст, ФайлПроекта.ПолноеИмя);

    Возврат СтруктураОтвета;

КонецФункции

Функция НормализоватьПроект(Путь)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Путь);
    OPI_Инструменты.ВернутьУправляющиеПоследовательности(Путь);

    ФайлБазы = Новый Файл(Путь);

    Если ФайлБазы.Существует() И ФайлБазы.ЭтоКаталог() Тогда

        Счетчик = 0;

        Пока ФайлБазы.Существует() Цикл

            НовыйПуть = Путь + "/new_project_" + Строка(Счетчик) + ".oint";
            ФайлБазы  = Новый Файл(НовыйПуть);

            Счетчик = Счетчик + 1;

        КонецЦикла;

    КонецЕсли;

    ПолныйПуть = ФайлБазы.ПолноеИмя;

    Если Не ФайлБазы.Существует() Тогда

        Результат = СоздатьНовыйПроект(ПолныйПуть);

        Если Результат["result"] Тогда
            Текст = "Файл проекта успешно создан!";
            Ответ = СформироватьОтвет(Истина, Текст, ПолныйПуть);
        Иначе
            Ответ = Результат;
        КонецЕсли;

    Иначе

        Текст = "Файл проекта по указанному пути уже существует!";
        Ответ = СформироватьОтвет(Ложь, Текст, ПолныйПуть);

    КонецЕсли;

    Возврат Ответ;

КонецФункции

Функция ПроверитьВосстановитьПроект(Знач Путь)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Путь);
    OPI_Инструменты.ВернутьУправляющиеПоследовательности(Путь);

    ФайлБазы = Новый Файл(Путь);
    ПолныйПуть = ФайлБазы.ПолноеИмя;

    Если Не ФайлБазы.Существует() Тогда
        Текст = "Файл проекта по указанному не существует!";
        Ответ = СформироватьОтвет(Ложь, Текст, ПолныйПуть);
    Иначе
        
        Результат = СоздатьНовыйПроект(ПолныйПуть);

        Если Результат["result"] Тогда
            Текст = "Файл проекта проверен и приведен к необходимому формату!";
            Ответ = СформироватьОтвет(Истина, Текст, ПолныйПуть);
        Иначе
            Ответ = Результат;
        КонецЕсли;

    КонецЕсли;

    Возврат Ответ;

КонецФункции

Функция ПолучитьСтруктуруИнициализацииМеханизмов(Знач Проект)

    Если Ложь Тогда
        IntegrationProxy = Неопределено;
    КонецЕсли;

    ОбработчикЗапросов = Новый("RequestsHandler");
    ОбъектОПИ          = Новый("LibraryComposition");
    ПланировщикЗаданий = Новый("Scheduler");
    
    КаталогиСервера    = ПолучитьКаталогиСервера();
    МодульПрокси       = IntegrationProxy;

    МенеджерСоединенийSQLite = Новый("SQLiteConnectionManager");
    МенеджерСоединенийSQLite.Инициализировать(Проект);

    ХранилищеНастроек = Новый("SettingsVault");
    ХранилищеНастроек.Инициализировать(МенеджерСоединенийSQLite, МодульПрокси);
    
    Логгер = Новый("Logger");
    Логгер.Инициализировать(ХранилищеНастроек);

    ПроцессорДействий = Новый("ActionsProcessor");
    ПроцессорДействий.Инициализировать(ОбъектОПИ, МодульПрокси, МенеджерСоединенийSQLite, Логгер, ХранилищеНастроек);

    СтруктураИнициализации = Новый Структура;
    СтруктураИнициализации.Вставить("ПутьПроекта"             , Проект);
    СтруктураИнициализации.Вставить("КаталогиСервера"         , КаталогиСервера);
    СтруктураИнициализации.Вставить("ОбработчикЗапросов"      , ОбработчикЗапросов);
    СтруктураИнициализации.Вставить("ОбъектОПИ"               , ОбъектОПИ);
    СтруктураИнициализации.Вставить("МодульПрокси"            , МодульПрокси);
    СтруктураИнициализации.Вставить("МенеджерСоединенийSQLite", МенеджерСоединенийSQLite);
    СтруктураИнициализации.Вставить("ХранилищеНастроек"       , ХранилищеНастроек);
    СтруктураИнициализации.Вставить("Логгер"                  , Логгер);
    СтруктураИнициализации.Вставить("ПроцессорДействий"       , ПроцессорДействий);
    СтруктураИнициализации.Вставить("ПланировщикЗаданий"      , ПланировщикЗаданий);

    Возврат СтруктураИнициализации;
    
КонецФункции

Функция СформироватьОтвет(Знач Результат, Знач Текст, Знач Путь = "")

    Ответ = Новый Структура("result,message", Результат, Текст);

    Если ЗначениеЗаполнено(Путь) Тогда
        Ответ.Вставить("path", Путь);
    КонецЕсли;

    Возврат Ответ;

КонецФункции

Функция КонстантноеЗначение(Знач Ключ)

    Если      Ключ = "ТаблицаОбработчиков"      Тогда Возврат "handlers"
    ИначеЕсли Ключ = "ТаблицаАргументов"        Тогда Возврат "arguments"
    ИначеЕсли Ключ = "ТаблицаНастроек"          Тогда Возврат "settings"
    ИначеЕсли Ключ = "ТаблицаОпцийОбработчиков" Тогда Возврат "options"
    ИначеЕсли Ключ = "ТаблицаЗаданий"           Тогда Возврат "scheduler_tasks"

    Иначе Возврат "" КонецЕсли;

КонецФункции

Функция ИменаКонстантТаблиц(Знач ТолькоОбработчики = Истина)

    МассивИмен = Новый Массив;
    МассивИмен.Добавить("ТаблицаОбработчиков");
    МассивИмен.Добавить("ТаблицаАргументов");

    Если Не ТолькоОбработчики Тогда
        МассивИмен.Добавить("ТаблицаНастроек");
        МассивИмен.Добавить("ТаблицаЗаданий");
    КонецЕсли;

    Возврат МассивИмен;

КонецФункции

Функция СоздатьНовыйПроект(Путь)

    ФайлОбъект = Новый Файл(Путь);

    Если Не ФайлОбъект.Существует() Тогда
        ПустойФайл = ПолучитьДвоичныеДанныеИзСтроки("");
        ПустойФайл.Записать(Путь);
    КонецЕсли;

    Результат = СоздатьТаблицуОбработчиков(Путь);

    Если Не Результат["result"] Тогда
        УдалитьФайлы(Путь);
        Возврат Результат;
    КонецЕсли;

    Результат = СоздатьТаблицуАргументов(Путь);

    Если Не Результат["result"] Тогда
        УдалитьФайлы(Путь);
        Возврат Результат;
    КонецЕсли;

    Результат = СоздатьТаблицуОпций(Путь);

    Если Не Результат["result"] Тогда
        УдалитьФайлы(Путь);
        Возврат Результат;
    КонецЕсли;

    Результат = СоздатьТаблицуНастроек(Путь);

    Если Не Результат["result"] Тогда
        УдалитьФайлы(Путь);
        Возврат Результат;
    КонецЕсли;

    Результат = УстановитьСтандартныеНастройки(Путь);

    Если Не Результат["result"] Тогда
        УдалитьФайлы(Путь);
        Возврат Результат;
    КонецЕсли;

    Результат = СоздатьТаблицуЗаданийПланировщика(Путь);

    Если Не Результат["result"] Тогда
        УдалитьФайлы(Путь);
        Возврат Результат;
    КонецЕсли;

    Возврат Результат;

КонецФункции

Функция СоздатьТаблицуОбработчиков(Путь)

    СтруктураТаблицы = Новый Структура();
    СтруктураТаблицы.Вставить("key"     , "TEXT PRIMARY KEY NOT NULL UNIQUE");
    СтруктураТаблицы.Вставить("library" , "TEXT");
    СтруктураТаблицы.Вставить("function", "TEXT");
    СтруктураТаблицы.Вставить("method"  , "TEXT");
    СтруктураТаблицы.Вставить("active"  , "BOOLEAN");

    ИмяТаблицыОбработчиков = КонстантноеЗначение("ТаблицаОбработчиков");  
    Результат              = OPI_SQLite.ГарантироватьТаблицу(ИмяТаблицыОбработчиков, СтруктураТаблицы, Путь);

    Возврат Результат;

КонецФункции

Функция СоздатьТаблицуАргументов(Путь)

    СтруктураТаблицы = Новый Соответствие();
    СтруктураТаблицы.Вставить("key"        , "TEXT");
    СтруктураТаблицы.Вставить("arg"        , "TEXT");
    СтруктураТаблицы.Вставить("value"      , "TEXT");
    СтруктураТаблицы.Вставить("strict"     , "BOOLEAN");

    ИмяТаблицыАргументов = КонстантноеЗначение("ТаблицаАргументов");
    Результат            = OPI_SQLite.ГарантироватьТаблицу(ИмяТаблицыАргументов, СтруктураТаблицы, Путь);

    Возврат Результат;

КонецФункции

Функция СоздатьТаблицуОпций(Путь)

    СтруктураТаблицы = Новый Соответствие();
    СтруктураТаблицы.Вставить("key"        , "TEXT");
    СтруктураТаблицы.Вставить("option"     , "TEXT");
    СтруктураТаблицы.Вставить("value"      , "TEXT");
    СтруктураТаблицы.Вставить("type"       , "TEXT");
    СтруктураТаблицы.Вставить("description", "TEXT");

    ИмяТаблицыАргументов = КонстантноеЗначение("ТаблицаОпцийОбработчиков");
    Результат            = OPI_SQLite.ГарантироватьТаблицу(ИмяТаблицыАргументов, СтруктураТаблицы, Путь);

    Возврат Результат;

КонецФункции

Функция СоздатьТаблицуНастроек(Путь)

    СтруктураТаблицы = Новый Соответствие();
    СтруктураТаблицы.Вставить("name"       , "TEXT PRIMARY KEY NOT NULL UNIQUE");
    СтруктураТаблицы.Вставить("description", "TEXT");
    СтруктураТаблицы.Вставить("value"      , "TEXT");
    СтруктураТаблицы.Вставить("type"       , "TEXT");

    ИмяТаблицыНастроек = КонстантноеЗначение("ТаблицаНастроек");
    Результат          = OPI_SQLite.ГарантироватьТаблицу(ИмяТаблицыНастроек, СтруктураТаблицы, Путь);

    Возврат Результат;

КонецФункции

Функция СоздатьТаблицуЗаданийПланировщика(Путь)

    СтруктураТаблицы = Новый Соответствие();
    СтруктураТаблицы.Вставить("id"         , "INTEGER PRIMARY KEY AUTOINCREMENT");
    СтруктураТаблицы.Вставить("handler"    , "TEXT");
    СтруктураТаблицы.Вставить("cron"       , "TEXT");
    СтруктураТаблицы.Вставить("active"     , "BOOLEAN");

    ИмяТаблицыНастроек = КонстантноеЗначение("ТаблицаЗаданий");
    Результат          = OPI_SQLite.ГарантироватьТаблицу(ИмяТаблицыНастроек, СтруктураТаблицы, Путь);

    Возврат Результат;

КонецФункции

Функция УстановитьСтандартныеНастройки(Путь)

    СтандартныеНастройки = ПолучитьСтандартныеНастройки();
    ИмяТаблицыНастроек   = КонстантноеЗначение("ТаблицаНастроек");

    Существующие = OPI_SQLite.ПолучитьЗаписи(ИмяТаблицыНастроек, "name", , , , Путь);

    Если Не Существующие["result"] Тогда
        Возврат Существующие;
    КонецЕсли;

    ТекущиеНастройки = Существующие["data"];

    СписокТекущих = Новый СписокЗначений();

    Для Каждого Настройка Из ТекущиеНастройки Цикл
        СписокТекущих.Добавить(Настройка["name"]);
    КонецЦикла;

    СтандартныеНастройки_ = Новый Массив;

    Для Каждого СтандартнаяНастройка Из СтандартныеНастройки Цикл

        ЗначениеНастройки = СтандартнаяНастройка.Значение;

        Если СписокТекущих.НайтиПоЗначению(ЗначениеНастройки["name"]) = Неопределено Тогда
            СтандартныеНастройки_.Добавить(ЗначениеНастройки);
        КонецЕсли;

    КонецЦикла;

    СтандартныеНастройки = СтандартныеНастройки_;

    Результат = OPI_SQLite.ДобавитьЗаписи(ИмяТаблицыНастроек, СтандартныеНастройки, , Путь);

    Возврат Результат;

КонецФункции

Функция ПолучитьСтандартныеНастройки()

    СписокНастроек = Новый Соответствие();
    ПоляНастроек   = "name,description,value,type";

    СписокНастроек.Вставить("ui_password"      , Новый Структура(ПоляНастроек, "ui_password"      , "Пароль входа веб-консоли", "admin", "string"));
    
    СписокНастроек.Вставить("res_wrapper"      , Новый Структура(ПоляНастроек, "res_wrapper"      , "Признак использования {'result':true, 'data': <основной ответ>} обертки Melezh над оригинальными ответами функций (не влияет на не-JSON ответы)", "true", "bool"));
    СписокНастроек.Вставить("req_max_size"     , Новый Структура(ПоляНастроек, "req_max_size"     , "Максимальный размер тела запроса, при превышении которого он не будет обработан (в байтах). 0 - без ограничений", "209715200", "number"));
    СписокНастроек.Вставить("logs_path"        , Новый Структура(ПоляНастроек, "logs_path"        , "Путь сохранения логов. Для отключения логирования установите пустое значение", КаталогЛогов(), "string"));
    СписокНастроек.Вставить("logs_req_headers" , Новый Структура(ПоляНастроек, "logs_req_headers" , "Логирование заголовков входящих запросов", "true", "bool"));
    СписокНастроек.Вставить("logs_req_body"    , Новый Структура(ПоляНастроек, "logs_req_body"    , "Логирование тела входящих запросов", "true", "bool"));
    СписокНастроек.Вставить("logs_req_max_size", Новый Структура(ПоляНастроек, "logs_req_max_size", "Отключение логирования logs_req_body для запросов, свыше этого размер (в байтах). 0 - без ограничений", "104857600", "number"));
    СписокНастроек.Вставить("logs_res_body"    , Новый Структура(ПоляНастроек, "logs_res_body"    , "Логирование тела исходящих ответов", "true", "bool"));
    СписокНастроек.Вставить("logs_res_max_size", Новый Структура(ПоляНастроек, "logs_res_max_size", "Отключение логирования logs_res_body для запросов, свыше этого размер (в байтах). 0 - без ограничений", "104857600", "number"));
    СписокНастроек.Вставить("base_path"        , Новый Структура(ПоляНастроек, "base_path"        , "Базовый путь API. Все маршруты будут доступны с указанного префикса. Например: /melezh", "", "string"));
    СписокНастроек.Вставить("ext_path"         , Новый Структура(ПоляНастроек, "ext_path"         , "Дополнительный каталог расширений (для применения требуется обновление кэша или перезагрузка)", "", "string"));
    СписокНастроек.Вставить("ui_show"          , Новый Структура(ПоляНастроек, "ui_show"          , "Включает и отключает доступность Web-консоли", "true", "bool"));
    СписокНастроек.Вставить("index_redirect"   , Новый Структура(ПоляНастроек, "index_redirect"   , "Заменяет вывод титульной (корневой) страницы Melezh на перенаправление по указанному пути", "", "string"));
    
    
    Возврат СписокНастроек;
    
КонецФункции

Функция ПолучитьUUID(Знач Длина)
    Возврат Лев(СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", ""), Длина);
КонецФункции

Функция ИзменитьПоляОбработчика(Знач Проект, Знач КлючОбработчика, Знач СтруктураЗаписи)

    Если СтруктураЗаписи.Количество() > 0 Тогда

        СтруктураФильтра = Новый Структура;

        СтруктураФильтра.Вставить("field", "key");
        СтруктураФильтра.Вставить("type" , "=");
        СтруктураФильтра.Вставить("value", КлючОбработчика);
        СтруктураФильтра.Вставить("raw"  , Ложь);

        ИмяТаблицыОбработчиков = КонстантноеЗначение("ТаблицаОбработчиков");

        Результат = OPI_SQLite.ОбновитьЗаписи(ИмяТаблицыОбработчиков
            , СтруктураЗаписи
            , СтруктураФильтра
            , Проект);

    Иначе
        Результат = СформироватьОтвет(Ложь, "Ничего не изменилось!");
    КонецЕсли;

    Возврат Результат;

КонецФункции

Функция ПереключитьОбработчикЗапросов(Знач Проект, Знач КлючОбработчика, Знач Активность)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(КлючОбработчика);
    OPI_ПреобразованиеТипов.ПолучитьБулево(Активность);

    Результат = ПроверитьСуществованиеПроекта(Проект);

    Если Не Результат["result"] Тогда
        Возврат Результат;
    Иначе
        Проект = Результат["path"];
    КонецЕсли;

    СтруктураЗаписи = Новый Структура("active", Активность);
    Результат       = ИзменитьПоляОбработчика(Проект, КлючОбработчика, СтруктураЗаписи);

    Возврат Результат;

КонецФункции

Функция КаталогЛогов()

    Попытка
        КаталогMelezh = СтрШаблон("%1%2", СтрЗаменить(КаталогВременныхФайлов(), "\", "/"), "Melezh");
        ФайлMelezh    = Новый Файл(КаталогMelezh);

        Если Не ФайлMelezh.Существует() Тогда
            СоздатьКаталог(КаталогMelezh);
        КонецЕсли;

        КаталогПроекта = СтрШаблон("%1/%2", КаталогMelezh, Строка(Новый УникальныйИдентификатор()));
        ФайлПроекта    = Новый Файл(КаталогПроекта);

        Если Не ФайлПроекта.Существует() Тогда
        
            СоздатьКаталог(КаталогПроекта);

        Иначе

            Пока ФайлПроекта.Существует() Цикл

                КаталогПроекта = СтрШаблон("%1/%2", КаталогMelezh, Строка(Новый УникальныйИдентификатор()));
                ФайлПроекта    = Новый Файл(КаталогПроекта);

            КонецЦикла;

            СоздатьКаталог(КаталогПроекта);

        КонецЕсли;
    Исключение
        КаталогПроекта = "";
    КонецПопытки;
    
    Возврат КаталогПроекта;

КонецФункции

#КонецОбласти

#Область Служебные

Функция ПолучитьКаталогиСервера()

    КаталогЗапуска = СтартовыйСценарий().Каталог;
    КаталогЗапуска = СтрЗаменить(КаталогЗапуска, "\", "/");

    ЭлементыПути = СтрРазделить(КаталогЗапуска, "/");

    ЭлементыПути.Удалить(ЭлементыПути.ВГраница());
    ЭлементыПути.Удалить(ЭлементыПути.ВГраница());

    КаталогОсновной = СтрСоединить(ЭлементыПути, "/");

    КаталогРасширений    = КаталогОсновной + "/extensions/Modules";
    КаталогКорня         = КаталогОсновной + "/ui" ;

    Возврат Новый Структура("Корень,Расширения", КаталогКорня, КаталогРасширений);

КонецФункции

Функция ПолучитьНастройку(Знач Имя, Знач Проект) 

    НастройкиИзБазы = ПолучитьНастройкиПроекта(Проект);
    Результат       = Неопределено;
	
	Если Не НастройкиИзБазы["result"] Тогда
		ВызватьИсключение НастройкиИзБазы["error"];	
	КонецЕсли;
		
	Для Каждого Настройка Из НастройкиИзБазы["data"] Цикл

		Если Настройка["name"] = Имя Тогда
			Результат = Настройка["value"];
		КонецЕсли;

	КонецЦикла;

    Возврат Результат;

КонецФункции

#КонецОбласти

#КонецОбласти