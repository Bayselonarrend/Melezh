
// MIT License

// Copyright (c) 2020 Tsukanov Alexander

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#Область Константы

Перем КлючевыеСлова;             
Перем Токены;                    
Перем Типы;                      
Перем Директивы;                 
Перем Аннотации;                 
Перем ИнструкцииПрепроцессора;   
Перем СимволыПрепроцессора;      
Перем Ошибки;                    
Перем ЛитералКромеСтроки;        
Перем ОперацииСравнения;         
Перем ОперацииАддитивные;        
Перем ОперацииМультипликативные; 
Перем ТокеныНачалаВыражения;     
Перем ПустойМассив;              
Перем КартаТокенов;              
Перем КартаБуквЦифр;             
Перем Буква, Цифра;              
Перем Символы_ПС;               

#КонецОбласти

#Область Parameters

Перем СтрогийРежим Экспорт;

#КонецОбласти 

#Область СостояниеПарсера

Перем Парсер_Исходник;                
Перем Парсер_ДлинаИсходника;          
Перем Парсер_НомерТекущейСтроки;      
Перем Парсер_ТекущаяПозиция;          
Перем Парсер_ПозицияНачалаТокена;     
Перем Парсер_Символ;                  
Перем Парсер_Токен;                   
Перем Парсер_Литерал;                 
Перем Парсер_Значение;                
Перем Парсер_Окружение;               
Перем Парсер_Переменные;              
Перем Парсер_Методы;                  
Перем Парсер_Неизвестные;             
Перем Парсер_ТочкиВызова;             
Перем Парсер_ЭтоФункция;              
Перем Парсер_ПеременныеРазрешены;     
Перем Парсер_СписокДиректив;          
Перем Парсер_СписокАннотаций;         
Перем Парсер_Интерфейс;               
Перем Парсер_Ошибки;                  
Перем Парсер_Замены;                  
Перем Парсер_Токены;                  
Перем Парсер_ПозицияТекущейСтроки;    
Перем Парсер_ИндексТокена;            
Перем Парсер_ДанныеТекущегоТокена;    
Перем Парсер_ДанныеПредыдущегоТокена; 
Перем Парсер_Узлы;                    

#КонецОбласти 

#Область СостояниеПосетителя

Перем Посетитель_Плагины;  
Перем Посетитель_Подписки; 
Перем Посетитель_Стек;     
Перем Посетитель_Счетчики; 

#КонецОбласти 

#Область Инициализация

Процедура Инициализировать()
	Перем Буквы, Индекс, Символ;

	ИнициализироватьПеречисления();
	ИнициализироватьУзлы();
	
	ЛитералКромеСтроки = Новый Массив;
	ЛитералКромеСтроки.Добавить(Токены.Число);
	ЛитералКромеСтроки.Добавить(Токены.ДатаВремя);
	ЛитералКромеСтроки.Добавить(Токены.Истина);
	ЛитералКромеСтроки.Добавить(Токены.Ложь);
	ЛитералКромеСтроки.Добавить(Токены.Неопределено);
	ЛитералКромеСтроки.Добавить(Токены.Null);

	ОперацииСравнения = Новый Массив;
	ОперацииСравнения.Добавить(Токены.ЗнакРавно);
	ОперацииСравнения.Добавить(Токены.ЗнакНеРавно);
	ОперацииСравнения.Добавить(Токены.ЗнакМеньше);
	ОперацииСравнения.Добавить(Токены.ЗнакБольше);
	ОперацииСравнения.Добавить(Токены.ЗнакМеньшеИлиРавно);
	ОперацииСравнения.Добавить(Токены.ЗнакБольшеИлиРавно);

	ОперацииАддитивные = Новый Массив;
	ОперацииАддитивные.Добавить(Токены.ЗнакСложения);
	ОперацииАддитивные.Добавить(Токены.ЗнакВычитания);

	ОперацииМультипликативные = Новый Массив;
	ОперацииМультипликативные.Добавить(Токены.ЗнакУмножения);
	ОперацииМультипликативные.Добавить(Токены.ЗнакДеления);
	ОперацииМультипликативные.Добавить(Токены.ЗнакОстатка);

	ТокеныНачалаВыражения = Новый Массив;
	ТокеныНачалаВыражения.Добавить(Токены.ЗнакСложения);
	ТокеныНачалаВыражения.Добавить(Токены.ЗнакВычитания);
	ТокеныНачалаВыражения.Добавить(Токены.Не);
	ТокеныНачалаВыражения.Добавить(Токены.Идентификатор);
	ТокеныНачалаВыражения.Добавить(Токены.ЛеваяКруглаяСкобка);
	ТокеныНачалаВыражения.Добавить(Токены.Число);
	ТокеныНачалаВыражения.Добавить(Токены.Строка);
	ТокеныНачалаВыражения.Добавить(Токены.НачалоСтроки);
	ТокеныНачалаВыражения.Добавить(Токены.ДатаВремя);
	ТокеныНачалаВыражения.Добавить(Токены.ЗнакВопроса);
	ТокеныНачалаВыражения.Добавить(Токены.Новый);
	ТокеныНачалаВыражения.Добавить(Токены.Истина);
	ТокеныНачалаВыражения.Добавить(Токены.Ложь);
	ТокеныНачалаВыражения.Добавить(Токены.Неопределено);
	ТокеныНачалаВыражения.Добавить(Токены.Null);

	ПустойМассив = Новый Массив;

	Символы_ПС = Символы.ПС;

	Буква = "Буква";
	Цифра = "Цифра";

	КартаТокенов = Новый Соответствие;
	КартаБуквЦифр = Новый Соответствие;

	Буквы = (
		"abcdefghijklmnopqrstuvwxyz"
		+ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		+ "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"
		+ "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
	);
	Индекс = 1;
	Символ = "_";
	Пока Символ <> "" Цикл
		КартаТокенов[Символ] = Буква;
		КартаБуквЦифр[Символ] = Буква;
		Символ = Сред(Буквы, Индекс, 1);
		Индекс = Индекс + 1;
	КонецЦикла;

	Для Индекс = 0 По 9 Цикл
		КартаТокенов[Строка(Индекс)] = Цифра;
		КартаБуквЦифр[Строка(Индекс)] = Цифра;
	КонецЦикла;

	КартаТокенов[""""] = Токены.НачалоСтроки;
	КартаТокенов["|"] = Токены.ПродолжениеСтроки;
	КартаТокенов["'"] = Токены.ДатаВремя;
	КартаТокенов["="] = Токены.ЗнакРавно;
	КартаТокенов["+"] = Токены.ЗнакСложения;
	КартаТокенов["-"] = Токены.ЗнакВычитания;
	КартаТокенов["*"] = Токены.ЗнакУмножения;
	КартаТокенов["%"] = Токены.ЗнакОстатка;
	КартаТокенов["("] = Токены.ЛеваяКруглаяСкобка;
	КартаТокенов[")"] = Токены.ПраваяКруглаяСкобка;
	КартаТокенов["["] = Токены.ЛеваяКвадратнаяСкобка;
	КартаТокенов["]"] = Токены.ПраваяКвадратнаяСкобка;
	КартаТокенов["?"] = Токены.ЗнакВопроса;
	КартаТокенов[","] = Токены.Запятая;
	КартаТокенов["."] = Токены.Точка;
	КартаТокенов[":"] = Токены.Двоеточие;
	КартаТокенов[";"] = Токены.ТочкаСЗапятой;
	КартаТокенов[""] = Токены.КонецТекста;

	Ошибки = Новый Массив(21);
	Ошибки[00] = Неопределено;
	Ошибки[01] = "Ожидалось";
	Ошибки[02] = "Ожидалась директива";
	Ошибки[03] = "Неизвестная директива";
	Ошибки[04] = "Ожидалась инструкция препроцессора";
	Ошибки[05] = "Неизвестная инструкция препроцессора";
	Ошибки[06] = "Не обнаружено объявление метода";
	Ошибки[07] = "Ожидался операнд";
	Ошибки[08] = "Ожидался конструктор";
	Ошибки[09] = "Ожидалось не более двух аргументов";
	Ошибки[10] = "Не обнаружено объявление идентификатора";
	Ошибки[11] = "Ожидалось выражение";
	Ошибки[12] = "Повторное объявление идентификатора";
	Ошибки[13] = "Повторное объявление метода";
	Ошибки[14] = "Ожидалась переменная";
	Ошибки[15] = "Name события указано неправильно";
	Ошибки[16] = "Name метода указано неправильно";
	Ошибки[17] = "Ожидался символ препроцессора";
	Ошибки[18] = "Ошибка в литерале даты";
	Ошибки[19] = "Не удалось выполнить замену";
	Ошибки[20] = "Ожидалось Name или путь";

	СтрогийРежим = Ложь;

	Парсер_Ошибки = Новый ТаблицаЗначений;

	Парсер_Ошибки.Колонки.Добавить("Источник", Новый ОписаниеТипов("Строка"));
	Парсер_Ошибки.Колонки.Добавить("Код", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	Парсер_Ошибки.Колонки.Добавить("ПозицияНачала", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("НомерСтрокиНачала", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("НомерКолонкиНачала", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("ПозицияКонца", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("НомерСтрокиКонца", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("НомерКолонкиКонца", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("ЕстьЗамена", Новый ОписаниеТипов("Булево"));

	Парсер_Ошибки.Колонки.Добавить("МинутНаИсправление", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("Серьезность", Новый ОписаниеТипов("Строка"));
	Парсер_Ошибки.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("Правило", Новый ОписаниеТипов("Строка"));
	Парсер_Ошибки.Колонки.Добавить("Type", Новый ОписаниеТипов("Строка"));

	Парсер_Токены = Новый ТаблицаЗначений;
	Парсер_Токены.Колонки.Добавить("Индекс", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("Токен", Новый ОписаниеТипов("Строка"));
	Парсер_Токены.Колонки.Добавить("LineNumber", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("НомерКолонки", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("Длина", Новый ОписаниеТипов("Число"));
	
	Парсер_Замены = Новый ТаблицаЗначений;
	Парсер_Замены.Колонки.Добавить("Источник", Новый ОписаниеТипов("Строка"));
	Парсер_Замены.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	Парсер_Замены.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	Парсер_Замены.Колонки.Добавить("Длина", Новый ОписаниеТипов("Число"));
	
КонецПроцедуры

Процедура ИнициализироватьПеречисления()
	КлючевыеСлова = КлючевыеСлова();
	Токены = Токены(КлючевыеСлова);
	Типы = Типы();
	Директивы = Директивы();
	Аннотации = Аннотации();
	ИнструкцииПрепроцессора = ИнструкцииПрепроцессора();
	СимволыПрепроцессора = СимволыПрепроцессора();
КонецПроцедуры

Процедура ИнициализироватьУзлы()
	
	Парсер_Узлы = Новый Структура;
	
	Парсер_Узлы.Вставить("Модуль", Новый ТаблицаЗначений);
	
	Поля = Парсер_Узлы.Модуль.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Declarations");
	Поля.Добавить("Переменные");
	Поля.Добавить("Операторы");
	Поля.Добавить("Интерфейс");
		
	Парсер_Узлы.Вставить("ЭлементОкружения", Новый ТаблицаЗначений);


	Поля = Парсер_Узлы.ЭлементОкружения.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("Объявление"); 
	
	ИнициализироватьОбъявления();
	ИнициализироватьВыражения();
	ИнициализироватьОператоры();
	ИнициализироватьИнструкцииПрепроцессора();		
	ИнициализироватьВыраженияПрепроцессора();

КонецПроцедуры 

Процедура ИнициализироватьОбъявления()
	
	Парсер_Узлы.Вставить("ОбъявлениеДирективы", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеДирективы.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Директива"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОбъявлениеАннотации", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеАннотации.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Аннотация");
	Поля.Добавить("ИмяМетода"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОбъявлениеСпискаПеременныхМодуля", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеСпискаПеременныхМодуля.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Директивы"); 
	Поля.Добавить("Declarations"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОбъявлениеПеременнойМодуля", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеПеременнойМодуля.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("Директивы"); 
	Поля.Добавить("Export"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОбъявлениеСпискаЛокальныхПеременных", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеСпискаЛокальныхПеременных.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Declarations"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОбъявлениеЛокальнойПеременной", Новый ТаблицаЗначений);
	
	Поля = Парсер_Узлы.ОбъявлениеЛокальнойПеременной.Колонки;
	Поля.Добавить("Type");
	Поля.Добавить("Name"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОбъявлениеАвтоПеременной", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеАвтоПеременной.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОбъявлениеПараметра", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеПараметра.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("ПоЗначению"); 
	Поля.Добавить("Value"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("MethodDeclaration", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.MethodDeclaration.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Signature");
	Поля.Добавить("Переменные");
	Поля.Добавить("Declarations");
	Поля.Добавить("Операторы");
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОбъявлениеСигнатурыПроцедуры", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеСигнатурыПроцедуры.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name");
	Поля.Добавить("Директивы");
	Поля.Добавить("Аннотации");
	Поля.Добавить("Parameters");
	Поля.Добавить("Export");
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОбъявлениеСигнатурыФункции", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеСигнатурыФункции.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("Директивы");
	Поля.Добавить("Аннотации");
	Поля.Добавить("Parameters");
	Поля.Добавить("Export");
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОбъявлениеГлобальногоОбъекта", Новый ТаблицаЗначений);
	
	Поля = Парсер_Узлы.ОбъявлениеГлобальногоОбъекта.Колонки;
	Поля.Добавить("Type");
	Поля.Добавить("Name");
	Поля.Добавить("Доступность"); 

	Парсер_Узлы.Вставить("ОбъявлениеГлобальногоМетода", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОбъявлениеГлобальногоМетода.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("Функция"); 
	Поля.Добавить("Parameters"); 
	Поля.Добавить("Доступность");
	
КонецПроцедуры 

Процедура ИнициализироватьВыражения()
	
	Парсер_Узлы.Вставить("ВыражениеЛитерал", Новый ТаблицаЗначений);
	
	Поля = Парсер_Узлы.ВыражениеЛитерал.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Вид");
	Поля.Добавить("Value"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ВыражениеПоле", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеПоле.Колонки;
	Поля.Добавить("Type");
	Поля.Добавить("Name");
	Поля.Добавить("Аргументы");
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ВыражениеИндекс", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеИндекс.Колонки;
	Поля.Добавить("Type");
	Поля.Добавить("Выражение");
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ВыражениеИдентификатор", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеИдентификатор.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Голова");
	Поля.Добавить("Хвост"); 
	Поля.Добавить("Аргументы");
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ВыражениеУнарное", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеУнарное.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Операция"); 
	Поля.Добавить("Операнд"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ВыражениеБинарное", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеБинарное.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("ЛевыйОперанд"); 
	Поля.Добавить("Операция"); 
	Поля.Добавить("ПравыйОперанд"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ВыражениеНовый", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеНовый.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("Аргументы"); 
	Поля.Добавить("Хвост"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ВыражениеТернарное", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеТернарное.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Тогда"); 
	Поля.Добавить("Иначе"); 
	Поля.Добавить("Хвост"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ВыражениеСкобочное", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеСкобочное.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ВыражениеНе", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеНе.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ВыражениеСтроковое", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеСтроковое.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Items"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");
	
КонецПроцедуры 

Процедура ИнициализироватьОператоры()
	
	Парсер_Узлы.Вставить("ОператорПрисваивания", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорПрисваивания.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("ЛевыйОперанд"); 
	Поля.Добавить("ПравыйОперанд"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорВозврат", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорВозврат.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорПрервать", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорПрервать.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОператорПродолжить", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорПродолжить.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорВызватьИсключение", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорВызватьИсключение.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорВыполнить", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорВыполнить.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорВызоваПроцедуры", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорВызоваПроцедуры.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Идентификатор"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОператорЕсли", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорЕсли.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение");
	Поля.Добавить("Тогда"); 
	Поля.Добавить("ИначеЕсли"); 
	Поля.Добавить("Иначе"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 
	Парсер_Узлы.Вставить("ОператорИначе", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорИначе.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Операторы");
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОператорИначеЕсли", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорИначеЕсли.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Тогда"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорПока", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорПока.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Операторы");
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОператорДля", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорДля.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Идентификатор"); 
	Поля.Добавить("Старт"); 
	Поля.Добавить("Финиш"); 
	Поля.Добавить("Операторы"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорДляКаждого", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорДляКаждого.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Идентификатор"); 
	Поля.Добавить("Коллекция"); 
	Поля.Добавить("Операторы"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорПопытка", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорПопытка.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Попытка"); 
	Поля.Добавить("Исключение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорИсключение", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорИсключение.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Операторы");
	Поля.Добавить("Start");
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорПерейти", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорПерейти.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Метка"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ОператорМетка", Новый ТаблицаЗначений);
	
	Поля = Парсер_Узлы.ОператорМетка.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Метка"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорДобавитьОбработчик", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорДобавитьОбработчик.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Событие"); 
	Поля.Добавить("ОбработчикСобытия"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ОператорУдалитьОбработчик", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ОператорУдалитьОбработчик.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Событие"); 
	Поля.Добавить("ОбработчикСобытия");
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 
	
КонецПроцедуры 

Процедура ИнициализироватьИнструкцииПрепроцессора()
	
	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораЕсли", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораЕсли.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораИначеЕсли", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораИначеЕсли.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораИначе", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораИначе.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораКонецЕсли", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораКонецЕсли.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("InstructionPreprocessorRegion", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.InstructionPreprocessorRegion.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Name"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораКонецОбласти", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораКонецОбласти.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораВставка", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораВставка.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораКонецВставки", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораКонецВставки.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораУдаление", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораУдаление.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораКонецУдаления", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораКонецУдаления.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ИнструкцияПрепроцессораИспользовать", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ИнструкцияПрепроцессораИспользовать.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Путь"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец");
	
КонецПроцедуры 

Процедура ИнициализироватьВыраженияПрепроцессора()
	
	Парсер_Узлы.Вставить("ВыражениеПрепроцессораБинарное", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеПрепроцессораБинарное.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("ЛевыйОперанд"); 
	Поля.Добавить("Операция"); 
	Поля.Добавить("ПравыйОперанд"); 
	Поля.Добавить("Start");
	Поля.Добавить("Конец");

	Парсер_Узлы.Вставить("ВыражениеПрепроцессораНе", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеПрепроцессораНе.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ВыражениеПрепроцессораСимвол", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеПрепроцессораСимвол.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Символ"); 
	Поля.Добавить("Существует"); 
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 

	Парсер_Узлы.Вставить("ВыражениеПрепроцессораСкобочное", Новый ТаблицаЗначений);

	Поля = Парсер_Узлы.ВыражениеПрепроцессораСкобочное.Колонки;
	Поля.Добавить("Type"); 
	Поля.Добавить("Выражение");
	Поля.Добавить("Start"); 
	Поля.Добавить("Конец"); 
	
КонецПроцедуры 

#КонецОбласти 

#Область Перечисления

Функция КлючевыеСлова() Экспорт
	Возврат Перечисление(Новый Структура,
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Процедура.Procedure, КонецПроцедуры.EndProcedure, Функция.Function, КонецФункции.EndFunction,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, Или.Or, Не.Not, ДобавитьОбработчик.AddHandler, УдалитьОбработчик.RemoveHandler,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.New, Выполнить.Execute, Экспорт.Export, Перейти.Goto,
		|Истина.True, Ложь.False, Неопределено.Undefined, Null"
	);
КонецФункции 

Функция Токены(КлючевыеСлова = Неопределено) Экспорт
	Перем Токены;

	Если КлючевыеСлова = Неопределено Тогда
		КлючевыеСлова = КлючевыеСлова();
	КонецЕсли;

	Токены = Перечисление(Новый Структура(КлючевыеСлова),

		"Идентификатор, Число, Строка, ДатаВремя,
		|НачалоСтроки, ПродолжениеСтроки, ОкончаниеСтроки,
		|ЗнакРавно, ЗнакНеРавно, ЗнакМеньше, ЗнакБольше,
		|ЗнакМеньшеИлиРавно, ЗнакБольшеИлиРавно,
		|ЗнакСложения, ЗнакВычитания, ЗнакУмножения, ЗнакДеления, ЗнакОстатка,
		|ЛеваяКруглаяСкобка, ПраваяКруглаяСкобка, ЛеваяКвадратнаяСкобка, ПраваяКвадратнаяСкобка,
		|ЗнакВопроса, Запятая, Точка, Двоеточие, ТочкаСЗапятой,
		|_Если, _ИначеЕсли, _Иначе, _КонецЕсли, _Область, _КонецОбласти,
		|_Вставка, _КонецВставки, _Удаление, _КонецУдаления, _Использовать,
		|Комментарий, Метка, Аннотация, Директива, НачалоТекста, КонецТекста,"
	);

	Возврат Токены;

КонецФункции 

Функция Типы() Экспорт
	Возврат Перечисление(Новый Структура,
		"Модуль, ЭлементОкружения, ОбъявлениеГлобальногоОбъекта, ОбъявлениеГлобальногоМетода,
		|ОбъявлениеДирективы, ОбъявлениеАннотации, ОбъявлениеПеременнойМодуля, ОбъявлениеСпискаПеременныхМодуля,
		|ОбъявлениеСпискаЛокальныхПеременных, ОбъявлениеЛокальнойПеременной, ОбъявлениеАвтоПеременной,
		|ОбъявлениеПараметра, MethodDeclaration, ОбъявлениеСигнатурыПроцедуры, ОбъявлениеСигнатурыФункции,
		|ВыражениеЛитерал, ВыражениеПоле, ВыражениеИндекс, ВыражениеИдентификатор,
		|ВыражениеУнарное, ВыражениеБинарное, ВыражениеНовый, ВыражениеТернарное,
		|ВыражениеСкобочное, ВыражениеНе, ВыражениеСтроковое,
		|ОператорПрисваивания, ОператорВозврат, ОператорПрервать, ОператорПродолжить,
		|ОператорВызватьИсключение, ОператорВыполнить, ОператорПока, ОператорДля, ОператорДляКаждого,
		|ОператорПопытка, ОператорИсключение, ОператорПерейти, ОператорМетка,
		|ОператорВызоваПроцедуры, ОператорЕсли, ОператорИначеЕсли, ОператорИначе,
		|ОператорДобавитьОбработчик, ОператорУдалитьОбработчик,
		|ИнструкцияПрепроцессораЕсли, ИнструкцияПрепроцессораИначеЕсли, ИнструкцияПрепроцессораИначе,
		|ИнструкцияПрепроцессораКонецЕсли, InstructionPreprocessorRegion, ИнструкцияПрепроцессораКонецОбласти,
		|ИнструкцияПрепроцессораВставка, ИнструкцияПрепроцессораКонецВставки,
		|ИнструкцияПрепроцессораУдаление, ИнструкцияПрепроцессораКонецУдаления,
		|ИнструкцияПрепроцессораИспользовать,
		|ВыражениеПрепроцессораБинарное, ВыражениеПрепроцессораНе,
		|ВыражениеПрепроцессораСимвол, ВыражениеПрепроцессораСкобочное"
	);
КонецФункции 

Функция Директивы() Экспорт
	Возврат Перечисление(Новый Структура,
		"НаКлиенте.AtClient,"
		"НаСервере.AtServer,"
		"НаСервереБезКонтекста.AtServerNoContext,"
		"НаКлиентеНаСервереБезКонтекста.AtClientAtServerNoContext,"
		"НаКлиентеНаСервере.AtClientAtServer"
	);
КонецФункции 

Функция Аннотации() Экспорт
	Возврат Перечисление(Новый Структура,
		"Перед.Before,"
		"После.After,"
		"Вместо.Around,"
		"ИзменениеИКонтроль.ChangeAndValidate,"
	);
КонецФункции 

Функция ИнструкцииПрепроцессора()
	Возврат Перечисление(Новый Структура,
		"Если.If,"
		"ИначеЕсли.ElsIf,"
		"Иначе.Else,"
		"КонецЕсли.EndIf,"
		"Область.Region,"
		"КонецОбласти.EndRegion,"
		"Вставка.Insert,"
		"КонецВставки.EndInsert,"
		"Удаление.Delete,"
		"КонецУдаления.EndDelete,"
		"Использовать.Use,"
	);
КонецФункции 

Функция СимволыПрепроцессора() Экспорт
	Возврат Перечисление(Новый Структура,
		"Клиент.Client,"
		"НаКлиенте.AtClient,"
		"НаСервере.AtServer,"
		"МобильноеПриложениеКлиент.MobileAppClient,"
		"МобильноеПриложениеСервер.MobileAppServer,"
		"ТолстыйКлиентОбычноеПриложение.ThickClientOrdinaryApplication,"
		"ТолстыйКлиентУправляемоеПриложение.ThickClientManagedApplication,"
		"Сервер.Server,"
		"ВнешнееСоединение.ExternalConnection,"
		"ТонкийКлиент.ThinClient,"
		"ВебКлиент.WebClient"
	);
КонецФункции 

Функция Перечисление(Структура, Ключи)
	Перем Items, Name, Имена, Value;

	Для Каждого Items Из СтрРазделить(Ключи, ",", Ложь) Цикл
		Имена = СтрРазделить(Items, ".", Ложь);
		Value = СокрЛП(Имена[0]);
		Для Каждого Name Из Имена Цикл
			Структура.Вставить(СокрЛП(Name), Value);
		КонецЦикла;
	КонецЦикла;

	Возврат Новый ФиксированнаяСтруктура(Структура);
КонецФункции 

#КонецОбласти

#Область Парсер

Функция СледующийТокен()
	Перем Start, ПредыдущийСимвол, Комментарий, ДанныеТокена;
	
	Парсер_Значение = Неопределено;

	Если Прав(Парсер_Литерал, 1) = Символы_ПС Тогда
		Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
		Парсер_ПозицияТекущейСтроки = Парсер_ТекущаяПозиция - 1;
	КонецЕсли;

	Пока Истина Цикл

		Комментарий = Ложь;

		Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
			Если Парсер_Символ = Символы_ПС Тогда
				Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
				Парсер_ПозицияТекущейСтроки = Парсер_ТекущаяПозиция;
			КонецЕсли;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
		КонецЦикла;

		Парсер_ПозицияНачалаТокена = Парсер_ТекущаяПозиция;

		Парсер_Токен = КартаТокенов[Парсер_Символ];
		Если Парсер_Токен = Буква Тогда

			Start = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			КонецЦикла;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);

			Если КлючевыеСлова.Свойство(Парсер_Литерал, Парсер_Токен) Тогда
				Если Парсер_Токен = Токены.Истина Тогда
					Парсер_Значение = Истина;
				ИначеЕсли Парсер_Токен = Токены.Ложь Тогда
					Парсер_Значение = Ложь;
				ИначеЕсли Парсер_Токен = Токены.Null Тогда
					Парсер_Значение = Null;
				КонецЕсли;
			Иначе
				Парсер_Токен = Токены.Идентификатор;
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Токены.НачалоСтроки Тогда

			Start = Парсер_ТекущаяПозиция;
			Парсер_Символ = """"; 
			Пока Парсер_Символ = """" Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Пока Парсер_Символ <> """" И Парсер_Символ <> Символы_ПС И Парсер_Символ <> "" Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;
				Если Парсер_Символ <> "" Тогда
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЕсли;
			КонецЦикла;

			Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);
			Парсер_Значение = СтрЗаменить(Сред(Парсер_Литерал, 2, СтрДлина(Парсер_Литерал) - 2), """""", """");
			Если Прав(Парсер_Литерал, 1) = """" Тогда
				Парсер_Токен = Токены.Строка;
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Токены.ПродолжениеСтроки Тогда

			Start = Парсер_ТекущаяПозиция;
			Парсер_Символ = """"; 
			Пока Парсер_Символ = """" Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Пока Парсер_Символ <> """" И Парсер_Символ <> Символы_ПС И Парсер_Символ <> "" Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;
				Если Парсер_Символ <> "" Тогда
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЕсли;
			КонецЦикла;

			Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);
			Парсер_Значение = СтрЗаменить(Сред(Парсер_Литерал, 2, СтрДлина(Парсер_Литерал) - 2), """""", """");
			Если Прав(Парсер_Литерал, 1) = """" Тогда
				Парсер_Токен = Токены.ОкончаниеСтроки;
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Цифра Тогда

			Start = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Цифра Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			КонецЦикла;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			Если Парсер_Символ = "." Тогда
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Цифра Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			КонецЕсли;
			Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);

			Парсер_Значение = Число(Парсер_Литерал);
			Парсер_Токен = Токены.Число;

		ИначеЕсли Парсер_Токен = Токены.ДатаВремя Тогда

			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Start = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = СтрНайти(Парсер_Исходник, "'", , Парсер_ТекущаяПозиция);
			Если Парсер_ТекущаяПозиция = 0 Тогда
				Парсер_Символ = "";
			Иначе
				Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Значение = КакДата(Парсер_Литерал);
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Неопределено Тогда

			ПредыдущийСимвол = Парсер_Символ;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);

			Если ПредыдущийСимвол = "/" Тогда

				Если Парсер_Символ = "/" Тогда
					Start = Парсер_ТекущаяПозиция + 1;
					Если Start < Парсер_ДлинаИсходника Тогда
						Парсер_ТекущаяПозиция = СтрНайти(Парсер_Исходник, Символы_ПС, , Start);
					Иначе
						Парсер_ТекущаяПозиция = 0;
					КонецЕсли;
					Если Парсер_ТекущаяПозиция = 0 Тогда
						Парсер_ТекущаяПозиция = Парсер_ДлинаИсходника + 1;
						Парсер_Символ = "";
					Иначе
						Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
					КонецЕсли;
					Парсер_ИндексТокена = Парсер_ИндексТокена + 1;
					ДанныеТокена = Парсер_Токены.Добавить();
					ДанныеТокена.Индекс = Парсер_ИндексТокена;
					ДанныеТокена.Токен = Токены.Комментарий;
					ДанныеТокена.LineNumber = Парсер_НомерТекущейСтроки;
					ДанныеТокена.НомерКолонки = Парсер_ПозицияНачалаТокена + 2 - Парсер_ПозицияТекущейСтроки;
					ДанныеТокена.Позиция = Парсер_ПозицияНачалаТокена + 2;
					ДанныеТокена.Длина = Парсер_ТекущаяПозиция - ДанныеТокена.Позиция; 
					Комментарий = Истина;
				Иначе
					Парсер_Токен = Токены.ЗнакДеления;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "<" Тогда

				Если Парсер_Символ = ">" Тогда
					Парсер_Токен = Токены.ЗнакНеРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				ИначеЕсли Парсер_Символ = "=" Тогда
					Парсер_Токен = Токены.ЗнакМеньшеИлиРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Иначе
					Парсер_Токен = Токены.ЗнакМеньше;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = ">" Тогда

				Если Парсер_Символ = "=" Тогда
					Парсер_Токен = Токены.ЗнакБольшеИлиРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Иначе
					Парсер_Токен = Токены.ЗнакБольше;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "&" Тогда

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Буква Тогда
					Ошибка(2, Неопределено, Истина);
				КонецЕсли;

				Start = Парсер_ТекущаяПозиция;
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);

				Если Директивы.Свойство(Парсер_Литерал) Тогда
					Парсер_Токен = Токены.Директива;	
				ИначеЕсли Аннотации.Свойство(Парсер_Литерал) Тогда
					Парсер_Токен = Токены.Аннотация;
				Иначе
					Ошибка(3, Парсер_Литерал, Ложь);
					Парсер_Токен = Токены.Директива;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "#" Тогда

				Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
					Если Парсер_Символ = Символы_ПС Тогда
						Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
						Парсер_ПозицияТекущейСтроки = Парсер_ТекущаяПозиция;
					КонецЕсли;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Буква Тогда
					Ошибка(4, Неопределено, Истина);
				КонецЕсли;

				Start = Парсер_ТекущаяПозиция;
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);

				Если ИнструкцииПрепроцессора.Свойство(Парсер_Литерал, Парсер_Токен) Тогда
					Парсер_Токен = "_" + Парсер_Токен;
				Иначе
					Ошибка(5, Парсер_Литерал, Истина);
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "~" Тогда

				Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
					Если Парсер_Символ = Символы_ПС Тогда
						Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
						Парсер_ПозицияТекущейСтроки = Парсер_ТекущаяПозиция;
					КонецЕсли;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Неопределено Тогда
					Парсер_Литерал = "";
				Иначе
					Start = Парсер_ТекущаяПозиция;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
						Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					КонецЦикла;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
					Парсер_Литерал = Сред(Парсер_Исходник, Start, Парсер_ТекущаяПозиция - Start);
				КонецЕсли;

				Парсер_Токен = Токены.Метка;

			Иначе

				ВызватьИсключение "Неизвестный символ!";

			КонецЕсли;

		Иначе

			Парсер_Литерал = Парсер_Символ;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);

		КонецЕсли;

		Если Не Комментарий Тогда
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Парсер_ДанныеПредыдущегоТокена = Парсер_ДанныеТекущегоТокена;
	
	Парсер_ИндексТокена = Парсер_ИндексТокена + 1;
	
	Парсер_ДанныеТекущегоТокена = Парсер_Токены.Добавить();
	Парсер_ДанныеТекущегоТокена.Индекс = Парсер_ИндексТокена;
	Парсер_ДанныеТекущегоТокена.Токен = Парсер_Токен;
	Парсер_ДанныеТекущегоТокена.LineNumber = Парсер_НомерТекущейСтроки;
	Парсер_ДанныеТекущегоТокена.НомерКолонки = Парсер_ПозицияНачалаТокена - Парсер_ПозицияТекущейСтроки;
	Парсер_ДанныеТекущегоТокена.Позиция = Парсер_ПозицияНачалаТокена;
	Парсер_ДанныеТекущегоТокена.Длина = Парсер_ТекущаяПозиция - Парсер_ДанныеТекущегоТокена.Позиция;

	Возврат Парсер_Токен;

КонецФункции 

Функция Окружение(ВнешнееОкружение = Неопределено) Экспорт
	Возврат Новый Структура(
		"ВнешнееОкружение," 
		"Переменные,"       
		"Методы,"           
		"АвтоПеременные",   
		ВнешнееОкружение, Новый Структура, Новый Структура, Новый Массив);
КонецФункции 

Функция НайтиЭлементОкружения(Name)
	Перем Окружение, ЭлементОкружения;
	Окружение = Парсер_Окружение;
	Окружение.Переменные.Свойство(Name, ЭлементОкружения);
	Пока ЭлементОкружения = Неопределено И Окружение.ВнешнееОкружение <> Неопределено Цикл
		Окружение = Окружение.ВнешнееОкружение;
		Окружение.Переменные.Свойство(Name, ЭлементОкружения);
	КонецЦикла;
	Возврат ЭлементОкружения;
КонецФункции 

Функция НайтиМетод(Name)
	Перем Окружение, Метод;
	Окружение = Парсер_Окружение;
	Окружение.Методы.Свойство(Name, Метод);
	Пока Метод = Неопределено И Окружение.ВнешнееОкружение <> Неопределено Цикл
		Окружение = Окружение.ВнешнееОкружение;
		Окружение.Методы.Свойство(Name, Метод);
	КонецЦикла;
	Возврат Метод;
КонецФункции

Функция ОткрытьОкружение()
	Перем Окружение;
	Окружение = Окружение(Парсер_Окружение);
	Парсер_Окружение = Окружение;
	Парсер_Переменные = Окружение.Переменные;
	Возврат Окружение;
КонецФункции 

Функция ЗакрытьОкружение()
	Перем Окружение;
	Окружение = Парсер_Окружение.ВнешнееОкружение;
	Парсер_Окружение = Окружение;
	Если Окружение <> Неопределено Тогда
		Парсер_Переменные = Окружение.Переменные;
	КонецЕсли;
	Возврат Окружение;
КонецФункции 

Функция Узлы() Экспорт
	Возврат Парсер_Узлы;
КонецФункции

Функция Токенизировать(Исходник) Экспорт
	Перем ПоследнийТокен;
	
	Парсер_Исходник = Исходник;
	Парсер_ТекущаяПозиция = 0;
	Парсер_НомерТекущейСтроки = 1;
	Парсер_ПозицияНачалаТокена = 0;
	Парсер_ПозицияТекущейСтроки = 0;
	Парсер_ДлинаИсходника = СтрДлина(Исходник);
	Парсер_Литерал = "";
	Парсер_Символ = Неопределено;
	Парсер_Ошибки.Очистить();
	Парсер_Токены.Очистить();
	Парсер_ИндексТокена = 0;
	Парсер_ДанныеТекущегоТокена = Парсер_Токены.Добавить();
	Парсер_ДанныеТекущегоТокена.Токен = Токены.НачалоТекста;
	Парсер_Замены.Очистить();
	
	Пока СледующийТокен() <> Токены.КонецТекста Цикл
	КонецЦикла;
	
	ПоследнийТокен = Парсер_Токены[Парсер_Токены.Количество() - 1];
	ПоследнийТокен.Длина = 0;
	
	Возврат Парсер_Токены;

КонецФункции

Функция ТаблицаТокенов() Экспорт
	Возврат Парсер_Токены;
КонецФункции

Процедура УстановитьТаблицуТокенов(ТаблицаТокенов) Экспорт
	Парсер_Токены = ТаблицаТокенов;
КонецПроцедуры

Функция ТаблицаЗамен() Экспорт
	Возврат Парсер_Замены; 
КонецФункции

Функция ВыполнитьЗамены() Экспорт
	Перем Результат, ПозицияНачала, Индекс, Замена;
	
	Если Парсер_Замены.Количество() = 0 Тогда
		Возврат Неопределено;   
	КонецЕсли;
	
	Результат = Новый Массив;
	
	Парсер_Замены.Сортировать("Позиция");
	
	ПозицияНачала = 1;
	
	Для Индекс = 0 По Парсер_Замены.Количество() - 1 Цикл
		
		Замена = Парсер_Замены[Индекс];
		
		Если Замена.Позиция < ПозицияНачала Тогда
			КодОшибки = 19;
			Ошибка = Парсер_Ошибки.Добавить();
			Ошибка.Источник = "ПарсерВстроенногоЯзыка";
			Ошибка.Код = КодОшибки;
			Ошибка.Текст = СтрШаблон(Ошибки[КодОшибки] + ": `%1`", Замена.Текст);
			Ошибка.ПозицияНачала = Замена.Позиция;
			Ошибка.ПозицияКонца = Замена.Позиция + Замена.Длина;
			Продолжить;
		КонецЕсли;
		
		Результат.Добавить(Сред(Парсер_Исходник, ПозицияНачала, Замена.Позиция - ПозицияНачала));
		Результат.Добавить(Замена.Текст);
		
		ПозицияНачала = Замена.Позиция + Замена.Длина;
		
	КонецЦикла;
	
	Результат.Добавить(Сред(Парсер_Исходник, ПозицияНачала));
	
	Возврат СтрСоединить(Результат);
	
КонецФункции

Функция Parse(Исходник, ВнешнееОкружение = Неопределено) Экспорт
	Перем Declarations, Переменные, ОбъявлениеАвтоПеременной, ЭлементОкружения, Операторы, Модуль, ТочкиВызова, ИндексТокена, ПоследнийТокен;

	Парсер_Исходник = Исходник;
	Парсер_ТекущаяПозиция = 0;
	Парсер_НомерТекущейСтроки = 1;
	Парсер_ПозицияТекущейСтроки = 0;
	Парсер_ПозицияНачалаТокена = 0;
	Парсер_Неизвестные = Новый Структура;
	Парсер_ТочкиВызова = Новый Соответствие;
	Парсер_ЭтоФункция = Ложь;
	Парсер_ПеременныеРазрешены = Истина;
	Парсер_Интерфейс = Новый Массив;
	Парсер_ДлинаИсходника = СтрДлина(Исходник);
	Парсер_Литерал = "";
	Парсер_Символ = Неопределено;
	Парсер_Ошибки.Очистить();
	Парсер_Токены.Очистить();
	Парсер_ИндексТокена = 0;
	Парсер_ДанныеТекущегоТокена = Парсер_Токены.Добавить();
	Парсер_ДанныеТекущегоТокена.Токен = Токены.НачалоТекста;
	Парсер_Замены.Очистить(); 
	
	Парсер_Окружение = ВнешнееОкружение;
	ОткрытьОкружение();
	Парсер_Методы = Парсер_Окружение.Методы;
	СледующийТокен();
	Переменные = Новый Массив;
	Declarations = РазобратьОбъявленияМодуля(Переменные);
	Операторы = РазобратьОператоры();
	Для Каждого ОбъявлениеАвтоПеременной Из Парсер_Окружение.АвтоПеременные Цикл
		Переменные.Добавить(ОбъявлениеАвтоПеременной);
	КонецЦикла;
	Модуль = Парсер_Узлы.Модуль.Добавить();
	Модуль.Type = Типы.Модуль;
	Модуль.Declarations = Declarations;
	Модуль.Переменные = Переменные;
	Модуль.Операторы = Операторы;
	Модуль.Интерфейс = Парсер_Интерфейс;
	Если СтрогийРежим Тогда
		Для Каждого ЭлементОкружения Из Парсер_Неизвестные Цикл
			ТочкиВызова = Парсер_ТочкиВызова[ЭлементОкружения.Value];
			Для Каждого ИндексТокена Из ТочкиВызова Цикл
				Ошибка(6, ЭлементОкружения.Ключ, Ложь, ИндексТокена);
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	Ожидать(Токены.КонецТекста);
	ЗакрытьОкружение();
	
	ПоследнийТокен = Парсер_Токены[Парсер_Токены.Количество() - 1];
	ПоследнийТокен.Длина = 0;
	
	Парсер_Неизвестные = Неопределено;
	Парсер_Методы = Неопределено;
	Парсер_СписокДиректив = Неопределено;
	Парсер_СписокАннотаций = Неопределено;
	Парсер_Интерфейс = Неопределено;
	Парсер_Окружение = Неопределено;
	Парсер_Переменные = Неопределено;

	Возврат Модуль;
КонецФункции 

Функция ТаблицаОшибок() Экспорт
	Возврат Парсер_Ошибки;
КонецФункции

Процедура УстановитьТаблицуОшибок(ТаблицаОшибок) Экспорт
	Парсер_Ошибки = ТаблицаОшибок;
КонецПроцедуры

Функция Исходник() Экспорт
	Возврат Парсер_Исходник;
КонецФункции

Процедура УстановитьИсходник(Исходник) Экспорт
	Парсер_Исходник = Исходник;
КонецПроцедуры

#Область РазборВыражений

Функция РазобратьВыражение()
	Перем Выражение, Операция, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Выражение = РазобратьВыражениеИ();
	Пока Парсер_Токен = Токены.Или Цикл
		Операция = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
		ЛевыйОперанд = Выражение;
		Выражение = Парсер_Узлы.ВыражениеБинарное.Добавить();
		Выражение.Type = Типы.ВыражениеБинарное;
		Выражение.ЛевыйОперанд = ЛевыйОперанд;
		Выражение.Операция = Операция;
		Выражение.ПравыйОперанд = РазобратьВыражениеИ();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЦикла;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеИ()
	Перем Выражение, Операция, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Выражение = РазобратьВыражениеНе();
	Пока Парсер_Токен = Токены.И Цикл
		Операция = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
		ЛевыйОперанд = Выражение;
		Выражение = Парсер_Узлы.ВыражениеБинарное.Добавить();
		Выражение.Type = Типы.ВыражениеБинарное;
		Выражение.ЛевыйОперанд = ЛевыйОперанд;
		Выражение.Операция = Операция;
		Выражение.ПравыйОперанд = РазобратьВыражениеНе();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЦикла;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеНе()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Если Парсер_Токен = Токены.Не Тогда
		СледующийТокен();
		Выражение = Парсер_Узлы.ВыражениеНе.Добавить();
		Выражение.Type = Типы.ВыражениеНе;
		Выражение.Выражение = РазобратьВыражениеОтношения();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	Иначе
		Выражение = РазобратьВыражениеОтношения();
	КонецЕсли;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеОтношения()
	Перем Выражение, Операция, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Выражение = РазобратьВыражениеАддитивное();
	Пока ОперацииСравнения.Найти(Парсер_Токен) <> Неопределено Цикл
		Операция = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
		ЛевыйОперанд = Выражение;
		Выражение = Парсер_Узлы.ВыражениеБинарное.Добавить();
		Выражение.Type = Типы.ВыражениеБинарное;
		Выражение.ЛевыйОперанд = ЛевыйОперанд;
		Выражение.Операция = Операция;
		Выражение.ПравыйОперанд = РазобратьВыражениеАддитивное();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЦикла;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеАддитивное()
	Перем Выражение, Операция, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Выражение = РазобратьВыражениеМультипликативное();
	Пока ОперацииАддитивные.Найти(Парсер_Токен) <> Неопределено Цикл
		Операция = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
		ЛевыйОперанд = Выражение;
		Выражение = Парсер_Узлы.ВыражениеБинарное.Добавить();
		Выражение.Type = Типы.ВыражениеБинарное;
		Выражение.ЛевыйОперанд = ЛевыйОперанд;
		Выражение.Операция = Операция;
		Выражение.ПравыйОперанд = РазобратьВыражениеМультипликативное();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЦикла;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеМультипликативное()
	Перем Выражение, Операция, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Выражение = РазобратьВыражениеУнарное();
	Пока ОперацииМультипликативные.Найти(Парсер_Токен) <> Неопределено Цикл
		Операция = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
		ЛевыйОперанд = Выражение;
		Выражение = Парсер_Узлы.ВыражениеБинарное.Добавить();
		Выражение.Type = Типы.ВыражениеБинарное;
		Выражение.ЛевыйОперанд = ЛевыйОперанд;
		Выражение.Операция = Операция;
		Выражение.ПравыйОперанд = РазобратьВыражениеУнарное();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЦикла;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеУнарное()
	Перем Операция, Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Операция = Парсер_ДанныеТекущегоТокена;
	Если ОперацииАддитивные.Найти(Парсер_Токен) <> Неопределено Тогда
		СледующийТокен();
		Выражение = Парсер_Узлы.ВыражениеУнарное.Добавить();
		Выражение.Type = Типы.ВыражениеУнарное;
		Выражение.Операция = Операция;
		Выражение.Операнд = РазобратьОперанд();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	ИначеЕсли Парсер_Токен = Токены.КонецТекста Тогда
		Выражение = Неопределено;
	Иначе
		Выражение = РазобратьОперанд();
	КонецЕсли;
	Возврат Выражение;
КонецФункции 

Функция РазобратьОперанд()
	Перем Операнд;
	Если Парсер_Токен = Токены.Строка Или Парсер_Токен = Токены.НачалоСтроки Тогда
		Операнд = РазобратьВыражениеСтроковое();
	ИначеЕсли ЛитералКромеСтроки.Найти(Парсер_Токен) <> Неопределено Тогда
		Операнд = Парсер_Узлы.ВыражениеЛитерал.Добавить();
		Операнд.Type = Типы.ВыражениеЛитерал;
		Операнд.Вид = Парсер_Токен;
		Операнд.Value = Парсер_Значение;
		Операнд.Start = Парсер_ДанныеТекущегоТокена;
		Операнд.Конец = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
	ИначеЕсли Парсер_Токен = Токены.Идентификатор Тогда
		Операнд = РазобратьВыражениеИдентификатор();
	ИначеЕсли Парсер_Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Операнд = РазобратьВыражениеСкобочное();
	ИначеЕсли Парсер_Токен = Токены.Новый Тогда
		Операнд = РазобратьВыражениеНовый();
	ИначеЕсли Парсер_Токен = Токены.ЗнакВопроса Тогда
		Операнд = РазобратьВыражениеТернарное();
	Иначе
		Ошибка(7, Неопределено, Истина, Парсер_ДанныеТекущегоТокена);
	КонецЕсли;
	Возврат Операнд;
КонецФункции 

Функция РазобратьВыражениеСтроковое()
	Перем СписокВыражений, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СписокВыражений = Новый Массив;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.Строка Тогда
			Узел = Парсер_Узлы.ВыражениеЛитерал.Добавить();
			Узел.Type = Типы.ВыражениеЛитерал;
			Узел.Вид = Парсер_Токен;
			Узел.Value = Парсер_Значение;
			Узел.Start = Парсер_ДанныеТекущегоТокена;
			Узел.Конец = Парсер_ДанныеТекущегоТокена;;
			СписокВыражений.Добавить(Узел);
			СледующийТокен();
			Пока Парсер_Токен = Токены.Строка Цикл
				Узел = Парсер_Узлы.ВыражениеЛитерал.Добавить();
				Узел.Type = Типы.ВыражениеЛитерал;
				Узел.Вид = Парсер_Токен;
				Узел.Value = Парсер_Значение;
				Узел.Start = Парсер_ДанныеТекущегоТокена;
				Узел.Конец = Парсер_ДанныеТекущегоТокена;;
				СписокВыражений.Добавить(Узел);
				СледующийТокен();
			КонецЦикла;
		ИначеЕсли Парсер_Токен = Токены.НачалоСтроки Тогда
			Узел = Парсер_Узлы.ВыражениеЛитерал.Добавить();
			Узел.Type = Типы.ВыражениеЛитерал;
			Узел.Вид = Парсер_Токен;
			Узел.Value = Парсер_Значение;
			Узел.Start = Парсер_ДанныеТекущегоТокена;
			Узел.Конец = Парсер_ДанныеТекущегоТокена;;
			СписокВыражений.Добавить(Узел);
			СледующийТокен();
			Пока Парсер_Токен = Токены.ПродолжениеСтроки Цикл
				Узел = Парсер_Узлы.ВыражениеЛитерал.Добавить();
				Узел.Type = Типы.ВыражениеЛитерал;
				Узел.Вид = Парсер_Токен;
				Узел.Value = Парсер_Значение;
				Узел.Start = Парсер_ДанныеТекущегоТокена;
				Узел.Конец = Парсер_ДанныеТекущегоТокена;;
				СписокВыражений.Добавить(Узел);
				СледующийТокен();
			КонецЦикла;
			Если Парсер_Токен <> Токены.ОкончаниеСтроки Тогда
				Ошибка(1, """", Истина, Парсер_ДанныеТекущегоТокена);
			КонецЕсли;
			Узел = Парсер_Узлы.ВыражениеЛитерал.Добавить();
			Узел.Type = Типы.ВыражениеЛитерал;
			Узел.Вид = Парсер_Токен;
			Узел.Value = Парсер_Значение;
			Узел.Start = Парсер_ДанныеТекущегоТокена;
			Узел.Конец = Парсер_ДанныеТекущегоТокена;;
			СписокВыражений.Добавить(Узел);
			СледующийТокен();
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Узел = Парсер_Узлы.ВыражениеСтроковое.Добавить();
	Узел.Type = Типы.ВыражениеСтроковое;
	Узел.Items = СписокВыражений;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьВыражениеНовый()
	Перем Name, Аргументы, Хвост, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Если Парсер_Токен = Токены.Идентификатор Тогда
		Name = Парсер_Литерал;
		Аргументы = ПустойМассив;
		СледующийТокен();
	КонецЕсли;
	Хвост = ПустойМассив;
	Если Парсер_Токен = Токены.ЛеваяКруглаяСкобка Тогда
		СледующийТокен();
		Если Парсер_Токен <> Токены.ПраваяКруглаяСкобка Тогда
			Аргументы = РазобратьАргументы();
			Ожидать(Токены.ПраваяКруглаяСкобка);
		КонецЕсли;
		СледующийТокен();
		Если Парсер_Токен = Токены.Точка Тогда
			Хвост = РазобратьХвост();
		КонецЕсли;
	КонецЕсли;
	Если Name = Неопределено Тогда
		Если Аргументы = Неопределено Тогда
			Ошибка(8, Неопределено, Истина, Парсер_ДанныеТекущегоТокена);
		ИначеЕсли Аргументы.Количество() > 2 Тогда
			Ошибка(9, Неопределено, Истина, Start, Парсер_ДанныеТекущегоТокена);
		КонецЕсли;
	КонецЕсли;
	Узел = Парсер_Узлы.ВыражениеНовый.Добавить();
	Узел.Type = Типы.ВыражениеНовый;
	Узел.Name = Name;
	Узел.Аргументы = Аргументы;
	Узел.Хвост = Хвост;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьВыражениеИдентификатор(Знач НоваяПеременнаяРазрешена = Ложь, НоваяПеременная = Неопределено, ЭтоВызов = Неопределено)
	Перем Name, ЭлементОкружения, Хвост, Аргументы, НачалоАвтоПеременной, ТочкиВызова, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Name = Парсер_Литерал;
	НачалоАвтоПеременной = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Если Парсер_Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Если СледующийТокен() = Токены.ПраваяКруглаяСкобка Тогда
			Аргументы = ПустойМассив;
		Иначе
			Аргументы = РазобратьАргументы();
		КонецЕсли;
		Ожидать(Токены.ПраваяКруглаяСкобка);
		СледующийТокен();
		ЭлементОкружения = НайтиМетод(Name);
		Если ЭлементОкружения = Неопределено Тогда
			Если Парсер_Неизвестные.Свойство(Name, ЭлементОкружения) Тогда
				ТочкиВызова = Парсер_ТочкиВызова[ЭлементОкружения];
				ТочкиВызова.Добавить(НачалоАвтоПеременной);
			Иначе
				ЭлементОкружения = Парсер_Узлы.ЭлементОкружения.Добавить();
				ЭлементОкружения.Type = Типы.ЭлементОкружения;
				ЭлементОкружения.Name = Name;
				ЭлементОкружения.Объявление = Неопределено;
				Парсер_Неизвестные.Вставить(Name, ЭлементОкружения);
				ТочкиВызова = Новый Массив;
				ТочкиВызова.Добавить(НачалоАвтоПеременной);
				Парсер_ТочкиВызова[ЭлементОкружения] = ТочкиВызова;
			КонецЕсли;
		КонецЕсли;
		ЭтоВызов = Истина;
		Хвост = РазобратьХвост(ЭтоВызов);
	Иначе
		ЭтоВызов = Ложь;
		Хвост = РазобратьХвост(ЭтоВызов);
		Если Хвост.Количество() > 0 Тогда
			НоваяПеременнаяРазрешена = Ложь;
		КонецЕсли;
		ЭлементОкружения = НайтиЭлементОкружения(Name);
		Если ЭлементОкружения = Неопределено Тогда
			Если НоваяПеременнаяРазрешена Тогда
				ЭлементОкружения = Парсер_Узлы.ЭлементОкружения.Добавить();
				ЭлементОкружения.Type = Типы.ЭлементОкружения;
				ЭлементОкружения.Name = Name;
				ЭлементОкружения.Объявление = Парсер_Узлы.ОбъявлениеАвтоПеременной.Добавить();
				ЭлементОкружения.Объявление.Type = Типы.ОбъявлениеАвтоПеременной;
				ЭлементОкружения.Объявление.Name = Name;
				ЭлементОкружения.Объявление.Start = НачалоАвтоПеременной;
				ЭлементОкружения.Объявление.Конец = НачалоАвтоПеременной;;
				НоваяПеременная = ЭлементОкружения;
			Иначе
				ЭлементОкружения = Парсер_Узлы.ЭлементОкружения.Добавить();
				ЭлементОкружения.Type = Типы.ЭлементОкружения;
				ЭлементОкружения.Name = Name;
				ЭлементОкружения.Объявление = Неопределено;
				Если СтрогийРежим Тогда
					Ошибка(10, Name, Ложь, Start);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Узел = Парсер_Узлы.ВыражениеИдентификатор.Добавить();
	Узел.Type = Типы.ВыражениеИдентификатор;
	Узел.Голова = ЭлементОкружения;
	Узел.Хвост = Хвост;
	Узел.Аргументы = Аргументы;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьХвост(Вызов = Неопределено)
	Перем Хвост, Name, Аргументы, Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Хвост = Новый Массив;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.Точка Тогда
			СледующийТокен();
			Если КартаБуквЦифр[Лев(Парсер_Литерал, 1)] <> Буква Или Не КлючевыеСлова.Свойство(Парсер_Литерал) Тогда
				Ожидать(Токены.Идентификатор);
			КонецЕсли;
			Name = Парсер_Литерал;
			Если СледующийТокен() = Токены.ЛеваяКруглаяСкобка Тогда
				Если СледующийТокен() = Токены.ПраваяКруглаяСкобка Тогда
					Аргументы = ПустойМассив;
				Иначе
					Аргументы = РазобратьАргументы();
				КонецЕсли;
				Ожидать(Токены.ПраваяКруглаяСкобка);
				СледующийТокен();
				Вызов = Истина;
			Иначе
				Аргументы = Неопределено;
				Вызов = Ложь;
			КонецЕсли;
			Узел = Парсер_Узлы.ВыражениеПоле.Добавить();
			Узел.Type = Типы.ВыражениеПоле;
			Узел.Name = Name;
			Узел.Аргументы = Аргументы;
			Узел.Start = Start;
			Узел.Конец = Парсер_ДанныеПредыдущегоТокена;;
			Хвост.Добавить(Узел);
		ИначеЕсли Парсер_Токен = Токены.ЛеваяКвадратнаяСкобка Тогда
			Вызов = Ложь;
			Если СледующийТокен() = Токены.ПраваяКвадратнаяСкобка Тогда
				Ошибка(11, Неопределено, Истина, Парсер_ДанныеТекущегоТокена);
			КонецЕсли;
			Выражение = РазобратьВыражение();
			Ожидать(Токены.ПраваяКвадратнаяСкобка);
			СледующийТокен();
			Узел = Парсер_Узлы.ВыражениеИндекс.Добавить();
			Узел.Type = Типы.ВыражениеИндекс;
			Узел.Выражение = Выражение;
			Узел.Start = Start;
			Узел.Конец = Парсер_ДанныеПредыдущегоТокена;;
			Хвост.Добавить(Узел);
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат Хвост;
КонецФункции 

Функция РазобратьАргументы()
	Перем СписокВыражений;
	СписокВыражений = Новый Массив;
	Пока Истина Цикл
		Если ТокеныНачалаВыражения.Найти(Парсер_Токен) <> Неопределено Тогда
			СписокВыражений.Добавить(РазобратьВыражение());
		Иначе
			СписокВыражений.Добавить(Неопределено);
		КонецЕсли;
		Если Парсер_Токен = Токены.Запятая Тогда
			СледующийТокен();
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат СписокВыражений;
КонецФункции 

Функция РазобратьВыражениеТернарное()
	Перем Выражение, ТогдаОператоры, ИначеОператоры, Хвост, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Ожидать(Токены.ЛеваяКруглаяСкобка);
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.Запятая);
	СледующийТокен();
	ТогдаОператоры = РазобратьВыражение();
	Ожидать(Токены.Запятая);
	СледующийТокен();
	ИначеОператоры = РазобратьВыражение();
	Ожидать(Токены.ПраваяКруглаяСкобка);
	Если СледующийТокен() = Токены.Точка Тогда
		Хвост = РазобратьХвост();
	Иначе
		Хвост = ПустойМассив;
	КонецЕсли;
	Узел = Парсер_Узлы.ВыражениеТернарное.Добавить();
	Узел.Type = Типы.ВыражениеТернарное;
	Узел.Выражение = Выражение;
	Узел.Тогда = ТогдаОператоры;
	Узел.Иначе = ИначеОператоры;
	Узел.Хвост = Хвост;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции

Функция РазобратьВыражениеСкобочное()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Узел = Парсер_Узлы.ВыражениеСкобочное.Добавить();
	Узел.Type = Типы.ВыражениеСкобочное;
	Узел.Выражение = Выражение;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции

#КонецОбласти

#Область РазборОбъявлений

Функция РазобратьОбъявленияМодуля(Переменные)
	Перем Declarations, ОбъявлениеДирективы;
	Declarations = Новый Массив;
	Пока Истина Цикл
		Парсер_СписокДиректив = Новый Массив;
		Парсер_СписокАннотаций = Новый Массив;
		Пока Истина Цикл
			Если Парсер_Токен = Токены.Директива Тогда
				ОбъявлениеДирективы = Парсер_Узлы.ОбъявлениеДирективы.Добавить();
				ОбъявлениеДирективы.Type = Типы.ОбъявлениеДирективы;
				ОбъявлениеДирективы.Директива = Директивы[Парсер_Литерал];
				ОбъявлениеДирективы.Start = Парсер_ДанныеТекущегоТокена;
				ОбъявлениеДирективы.Конец = Парсер_ДанныеТекущегоТокена;
				Парсер_СписокДиректив.Добавить(ОбъявлениеДирективы);
				СледующийТокен();
			ИначеЕсли Парсер_Токен = Токены.Аннотация Тогда
				Аннотация = Аннотации[Парсер_Литерал];
				НачалоАннотации = Парсер_ДанныеТекущегоТокена;
				СледующийТокен();
				Ожидать(Токены.ЛеваяКруглаяСкобка);
				СледующийТокен();
				Ожидать(Токены.Строка);
				ИмяМетода = Парсер_Значение;
				СледующийТокен();
				Ожидать(Токены.ПраваяКруглаяСкобка);
				ОбъявлениеАннотации = Парсер_Узлы.ОбъявлениеАннотации.Добавить();
				ОбъявлениеАннотации.Type = Типы.ОбъявлениеАннотации;
				ОбъявлениеАннотации.Аннотация = Аннотация;
				ОбъявлениеАннотации.ИмяМетода = ИмяМетода;
				ОбъявлениеАннотации.Start = НачалоАннотации;
				ОбъявлениеАннотации.Конец = Парсер_ДанныеТекущегоТокена;
				Парсер_СписокАннотаций.Добавить(ОбъявлениеАннотации);
				СледующийТокен();
			Иначе
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если Парсер_Токен = Токены.Перем И Парсер_ПеременныеРазрешены Тогда
			Declarations.Добавить(РазобратьОбъявлениеСпискаПеременныхМодуля(Переменные));
		ИначеЕсли Парсер_Токен = Токены.Функция Тогда
			Парсер_ЭтоФункция = Истина;
			Declarations.Добавить(РазобратьОбъявлениеМетода());
			Парсер_ЭтоФункция = Ложь;
			Парсер_ПеременныеРазрешены = Ложь;
		ИначеЕсли Парсер_Токен = Токены.Процедура Тогда
			Declarations.Добавить(РазобратьОбъявлениеМетода());
			Парсер_ПеременныеРазрешены = Ложь;
		ИначеЕсли Парсер_Токен = Токены._Область Тогда
			Declarations.Добавить(РазобратьИнструкциюПрепроцессораОбласть());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._КонецОбласти Тогда
			Declarations.Добавить(РазобратьИнструкциюПрепроцессораКонецОбласти());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Если Тогда
			Declarations.Добавить(РазобратьИнструкциюПрепроцессораЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._ИначеЕсли Тогда
			Declarations.Добавить(РазобратьИнструкциюПрепроцессораИначеЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Иначе Тогда
			Declarations.Добавить(РазобратьИнструкциюПрепроцессораИначе());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._КонецЕсли Тогда
			Declarations.Добавить(РазобратьИнструкциюПрепроцессораКонецЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Использовать Тогда
			Declarations.Добавить(РазобратьИнструкциюПрепроцессораИспользовать());
			СледующийТокен();	
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат Declarations;
КонецФункции 

Функция РазобратьОбъявлениеСпискаПеременныхМодуля(Переменные)
	Перем ОбъявленияПеременных, ОбъявлениеПеременной, Объявление, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	ОбъявленияПеременных = Новый Массив;
	ОбъявлениеПеременной = РазобратьОбъявлениеПеременнойМодуля(); 
	ОбъявленияПеременных.Добавить(ОбъявлениеПеременной);
	Переменные.Добавить(ОбъявлениеПеременной);
	Пока Парсер_Токен = Токены.Запятая Цикл
		СледующийТокен();
		ОбъявлениеПеременной = РазобратьОбъявлениеПеременнойМодуля();
		ОбъявленияПеременных.Добавить(ОбъявлениеПеременной);
		Переменные.Добавить(ОбъявлениеПеременной);
	КонецЦикла;
	Объявление = Парсер_Узлы.ОбъявлениеСпискаПеременныхМодуля.Добавить();
	Объявление.Type = Типы.ОбъявлениеСпискаПеременныхМодуля;
	Объявление.Директивы = Парсер_СписокДиректив;
	Объявление.Declarations = ОбъявленияПеременных;
	Объявление.Start = Start;
	Объявление.Конец = Парсер_ДанныеПредыдущегоТокена;
	Ожидать(Токены.ТочкаСЗапятой);
	СледующийТокен();
	Пока Парсер_Токен = Токены.ТочкаСЗапятой Цикл
		СледующийТокен();
	КонецЦикла;
	Возврат Объявление;
КонецФункции

Функция РазобратьОбъявлениеПеременнойМодуля()
	Перем Name, ОбъявлениеПеременнойМодуля, ЭлементОкружения, ЕстьЭкспорт, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Ожидать(Токены.Идентификатор);
	Name = Парсер_Литерал;
	Если СледующийТокен() = Токены.Export Тогда
		ЕстьЭкспорт = Истина;
		СледующийТокен();
	Иначе
		ЕстьЭкспорт = Ложь;
	КонецЕсли;
	ОбъявлениеПеременнойМодуля = Парсер_Узлы.ОбъявлениеПеременнойМодуля.Добавить();
	ОбъявлениеПеременнойМодуля.Type = Типы.ОбъявлениеПеременнойМодуля;
	ОбъявлениеПеременнойМодуля.Name = Name;
	ОбъявлениеПеременнойМодуля.Директивы = Парсер_СписокДиректив;
	ОбъявлениеПеременнойМодуля.Export = ЕстьЭкспорт;
	ОбъявлениеПеременнойМодуля.Start = Start;
	ОбъявлениеПеременнойМодуля.Конец = Парсер_ДанныеПредыдущегоТокена;
	Если Парсер_Переменные.Свойство(Name) Тогда
		Ошибка(12, Name, СтрогийРежим, Start);
	КонецЕсли;
	ЭлементОкружения = Парсер_Узлы.ЭлементОкружения.Добавить();
	ЭлементОкружения.Type = Типы.ЭлементОкружения;
	ЭлементОкружения.Name = Name;
	ЭлементОкружения.Объявление = ОбъявлениеПеременнойМодуля;
	Парсер_Переменные.Вставить(Name, ЭлементОкружения);
	Если ЕстьЭкспорт Тогда
		Парсер_Интерфейс.Добавить(ЭлементОкружения);
	КонецЕсли;
	Возврат ОбъявлениеПеременнойМодуля;
КонецФункции 

Функция РазобратьОбъявлениеСпискаЛокальныхПеременных(Переменные)
	Перем ОбъявленияПеременных, ОбъявлениеПеременной, Объявление, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	ОбъявленияПеременных = Новый Массив;
	ОбъявлениеПеременной = РазобратьОбъявлениеЛокальнойПеременной(); 
	ОбъявленияПеременных.Добавить(ОбъявлениеПеременной);
	Переменные.Добавить(ОбъявлениеПеременной);
	Пока Парсер_Токен = Токены.Запятая Цикл
		СледующийТокен();
		ОбъявлениеПеременной = РазобратьОбъявлениеЛокальнойПеременной();
		ОбъявленияПеременных.Добавить(ОбъявлениеПеременной);
		Переменные.Добавить(ОбъявлениеПеременной);
	КонецЦикла;
	Объявление = Парсер_Узлы.ОбъявлениеСпискаЛокальныхПеременных.Добавить();
	Объявление.Type = Типы.ОбъявлениеСпискаЛокальныхПеременных;
	Объявление.Declarations = ОбъявленияПеременных;
	Объявление.Start = Start;
	Объявление.Конец = Парсер_ДанныеПредыдущегоТокена;
	Ожидать(Токены.ТочкаСЗапятой);
	СледующийТокен();
	Пока Парсер_Токен = Токены.ТочкаСЗапятой Цикл
		СледующийТокен();
	КонецЦикла;
	Возврат Объявление;
КонецФункции 

Функция РазобратьОбъявлениеЛокальнойПеременной()
	Перем Name, ОбъявлениеЛокальнойПеременной, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Ожидать(Токены.Идентификатор);
	Name = Парсер_Литерал;
	ОбъявлениеЛокальнойПеременной = Парсер_Узлы.ОбъявлениеЛокальнойПеременной.Добавить();
	ОбъявлениеЛокальнойПеременной.Type = Типы.ОбъявлениеЛокальнойПеременной;
	ОбъявлениеЛокальнойПеременной.Name = Name;
	ОбъявлениеЛокальнойПеременной.Start = Start;
	ОбъявлениеЛокальнойПеременной.Конец = Start;
	Если Парсер_Переменные.Свойство(Name) Тогда
		Ошибка(12, Name, СтрогийРежим, Парсер_ДанныеТекущегоТокена);
	КонецЕсли;
	ЭлементОкружения = Парсер_Узлы.ЭлементОкружения.Добавить();
	ЭлементОкружения.Type = Типы.ЭлементОкружения;
	ЭлементОкружения.Name = Name;
	ЭлементОкружения.Объявление = ОбъявлениеЛокальнойПеременной;;
	Парсер_Переменные.Вставить(Name, ЭлементОкружения);
	СледующийТокен();
	Возврат ОбъявлениеЛокальнойПеременной;
КонецФункции 

Функция РазобратьОбъявлениеМетода()
	Перем Signature, ЭлементОкружения, Name, Переменные, Parameters, ЕстьЭкспорт, Операторы, Declarations, ОбъявлениеАвтоПеременной, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	ЕстьЭкспорт = Ложь;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Name = Парсер_Литерал;
	СледующийТокен();
	ОткрытьОкружение();
	Parameters = РазобратьПараметры();
	Если Парсер_Токен = Токены.Export Тогда
		ЕстьЭкспорт = Истина;
		СледующийТокен();
	КонецЕсли;
	Если Парсер_ЭтоФункция Тогда
		Signature = Парсер_Узлы.ОбъявлениеСигнатурыФункции.Добавить();
		Signature.Type = Типы.ОбъявлениеСигнатурыФункции;
		Signature.Name = Name;
		Signature.Директивы = Парсер_СписокДиректив;
		Signature.Аннотации = Парсер_СписокАннотаций;
		Signature.Parameters = Parameters;
		Signature.Export = ЕстьЭкспорт;
		Signature.Start = Start;
		Signature.Конец = Парсер_ДанныеПредыдущегоТокена;
	Иначе
		Signature = Парсер_Узлы.ОбъявлениеСигнатурыПроцедуры.Добавить();
		Signature.Type = Типы.ОбъявлениеСигнатурыПроцедуры;
		Signature.Name = Name;
		Signature.Директивы = Парсер_СписокДиректив;
		Signature.Аннотации = Парсер_СписокАннотаций;
		Signature.Parameters = Parameters;
		Signature.Export = ЕстьЭкспорт;
		Signature.Start = Start;
		Signature.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЕсли;
	Если Парсер_Неизвестные.Свойство(Name, ЭлементОкружения) Тогда
		Парсер_Неизвестные.Удалить(Name);
		ЭлементОкружения.Объявление = Signature;
	Иначе
		ЭлементОкружения = Парсер_Узлы.ЭлементОкружения.Добавить();
		ЭлементОкружения.Type = Типы.ЭлементОкружения;
		ЭлементОкружения.Name = Name;
		ЭлементОкружения.Объявление = Signature;
	КонецЕсли;
	Если НайтиМетод(Name) <> Неопределено Тогда
		Ошибка(13, Name, СтрогийРежим, Парсер_Токены[Start.Индекс + 1]);
	КонецЕсли;
	Парсер_Методы.Вставить(Name, ЭлементОкружения);
	Если ЕстьЭкспорт Тогда
		Парсер_Интерфейс.Добавить(ЭлементОкружения);
	КонецЕсли;
	Declarations = Новый Массив;
	Переменные = Новый Массив;	
	Пока Парсер_Токен = Токены.Перем Цикл
		Declarations.Добавить(РазобратьОбъявлениеСпискаЛокальныхПеременных(Переменные));
	КонецЦикла;
	Операторы = РазобратьОператоры();
	Если Парсер_ЭтоФункция Тогда
		Ожидать(Токены.КонецФункции);
	Иначе
		Ожидать(Токены.КонецПроцедуры);
	КонецЕсли;
	Для Каждого ОбъявлениеАвтоПеременной Из Парсер_Окружение.АвтоПеременные Цикл
		Переменные.Добавить(ОбъявлениеАвтоПеременной);
	КонецЦикла;
	ЗакрытьОкружение();
	СледующийТокен();
	Узел = Парсер_Узлы.MethodDeclaration.Добавить();
	Узел.Type = Типы.MethodDeclaration;
	Узел.Signature = Signature;
	Узел.Переменные = Переменные;
	Узел.Declarations = Declarations;
	Узел.Операторы = Операторы;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьПараметры()
	Перем Parameters;
	Ожидать(Токены.ЛеваяКруглаяСкобка);
	СледующийТокен();
	Если Парсер_Токен = Токены.ПраваяКруглаяСкобка Тогда
		Parameters = ПустойМассив;
	Иначе
		Parameters = Новый Массив;
		Parameters.Добавить(РазобратьОбъявлениеПараметра());
		Пока Парсер_Токен = Токены.Запятая Цикл
			СледующийТокен();
			Parameters.Добавить(РазобратьОбъявлениеПараметра());
		КонецЦикла;
	КонецЕсли;
	Ожидать(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Возврат Parameters;
КонецФункции 

Функция РазобратьОбъявлениеПараметра()
	Перем Name, ОбъявлениеПараметра, ПоЗначению, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Если Парсер_Токен = Токены.Знач Тогда
		ПоЗначению = Истина;
		СледующийТокен();
	Иначе
		ПоЗначению = Ложь;
	КонецЕсли;
	Ожидать(Токены.Идентификатор);
	Name = Парсер_Литерал;
	Если СледующийТокен() = Токены.ЗнакРавно Тогда
		СледующийТокен();
		ОбъявлениеПараметра = Парсер_Узлы.ОбъявлениеПараметра.Добавить();
		ОбъявлениеПараметра.Type = Типы.ОбъявлениеПараметра;
		ОбъявлениеПараметра.Name = Name;
		ОбъявлениеПараметра.ПоЗначению = ПоЗначению;
		ОбъявлениеПараметра.Value = РазобратьВыражениеУнарное();
		ОбъявлениеПараметра.Start = Start;
		ОбъявлениеПараметра.Конец = Парсер_ДанныеПредыдущегоТокена;
	Иначе
		ОбъявлениеПараметра = Парсер_Узлы.ОбъявлениеПараметра.Добавить();
		ОбъявлениеПараметра.Type = Типы.ОбъявлениеПараметра;
		ОбъявлениеПараметра.Name = Name;
		ОбъявлениеПараметра.ПоЗначению = ПоЗначению;
		ОбъявлениеПараметра.Value = Неопределено;
		ОбъявлениеПараметра.Start = Start;
		ОбъявлениеПараметра.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЕсли;
	Если Парсер_Переменные.Свойство(Name) Тогда
		Ошибка(12, Name, СтрогийРежим, Start);
	КонецЕсли;
	ЭлементОкружения = Парсер_Узлы.ЭлементОкружения.Добавить();
	ЭлементОкружения.Type = Типы.ЭлементОкружения;
	ЭлементОкружения.Name = Name;
	ЭлементОкружения.Объявление = ОбъявлениеПараметра;;
	Парсер_Переменные.Вставить(Name, ЭлементОкружения);
	Возврат ОбъявлениеПараметра;
КонецФункции 

#КонецОбласти 

#Область РазборОператоров

Функция РазобратьОператоры()
	Перем Операторы, Оператор;
	Операторы = Новый Массив;
	Оператор = РазобратьОператор();
	Если Оператор <> Неопределено Тогда
		Операторы.Добавить(Оператор);
	КонецЕсли;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.ТочкаСЗапятой Тогда
			СледующийТокен();
		ИначеЕсли Лев(Парсер_Токен, 1) <> "_" Тогда 
			Прервать;
		КонецЕсли;
		Оператор = РазобратьОператор();
		Если Оператор <> Неопределено Тогда
			Операторы.Добавить(Оператор);
		КонецЕсли;
	КонецЦикла;
	Возврат Операторы;
КонецФункции 

Функция РазобратьОператор()
	Перем Оператор;
	Если Парсер_Токен = Токены.Идентификатор Тогда
		Оператор = РазобратьОператорПрисваиванияИлиВызоваПроцедуры();
	ИначеЕсли Парсер_Токен = Токены.Если Тогда
		Оператор = РазобратьОператорЕсли();
	ИначеЕсли Парсер_Токен = Токены.Попытка Тогда
		Оператор = РазобратьОператорПопытка();
	ИначеЕсли Парсер_Токен = Токены.Пока Тогда
		Оператор = РазобратьОператорПока();
	ИначеЕсли Парсер_Токен = Токены.Для Тогда
		Если СледующийТокен() = Токены.Каждого Тогда
			Оператор = РазобратьОператорДляКаждого();
		Иначе
			Оператор = РазобратьОператорДля();
		КонецЕсли;
	ИначеЕсли Парсер_Токен = Токены.Возврат Тогда
		Оператор = РазобратьОператорВозврат();
	ИначеЕсли Парсер_Токен = Токены.Прервать Тогда
		Оператор = РазобратьОператорПрервать();
	ИначеЕсли Парсер_Токен = Токены.Продолжить Тогда
		Оператор = РазобратьОператорПродолжить();
	ИначеЕсли Парсер_Токен = Токены.ВызватьИсключение Тогда
		Оператор = РазобратьОператорВызватьИсключение();
	ИначеЕсли Парсер_Токен = Токены.Выполнить Тогда
		Оператор = РазобратьОператорВыполнить();
	ИначеЕсли Парсер_Токен = Токены.Перейти Тогда
		Оператор = РазобратьОператорПерейти();
	ИначеЕсли Парсер_Токен = Токены.Метка Тогда
		Оператор = РазобратьОператорМетка();
	ИначеЕсли Парсер_Токен = Токены.ДобавитьОбработчик Тогда
		Оператор = РазобратьОператорДобавитьОбработчик();
	ИначеЕсли Парсер_Токен = Токены.УдалитьОбработчик Тогда
		Оператор = РазобратьОператорУдалитьОбработчик();
	ИначеЕсли Парсер_Токен = Токены._Область Тогда
		Оператор = РазобратьИнструкциюПрепроцессораОбласть();
	ИначеЕсли Парсер_Токен = Токены._КонецОбласти Тогда
		Оператор = РазобратьИнструкциюПрепроцессораКонецОбласти();
	ИначеЕсли Парсер_Токен = Токены._Если Тогда
		Оператор = РазобратьИнструкциюПрепроцессораЕсли();
	ИначеЕсли Парсер_Токен = Токены._ИначеЕсли Тогда
		Оператор = РазобратьИнструкциюПрепроцессораИначеЕсли();
	ИначеЕсли Парсер_Токен = Токены._Иначе Тогда
		Оператор = РазобратьИнструкциюПрепроцессораИначе();
	ИначеЕсли Парсер_Токен = Токены._КонецЕсли Тогда
		Оператор = РазобратьИнструкциюПрепроцессораКонецЕсли();
	ИначеЕсли Парсер_Токен = Токены._Вставка Тогда
		Оператор = РазобратьИнструкциюПрепроцессораВставка();
	ИначеЕсли Парсер_Токен = Токены._КонецВставки Тогда
		Оператор = РазобратьИнструкциюПрепроцессораКонецВставки();
		ИначеЕсли Парсер_Токен = Токены._Удаление Тогда
		Оператор = РазобратьИнструкциюПрепроцессораУдаление();
	ИначеЕсли Парсер_Токен = Токены._КонецУдаления Тогда
		Оператор = РазобратьИнструкциюПрепроцессораКонецУдаления();
	ИначеЕсли Парсер_Токен = Токены.ТочкаСЗапятой Тогда
		
	КонецЕсли;
	Возврат Оператор;
КонецФункции 

Функция РазобратьОператорВызватьИсключение()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Если ТокеныНачалаВыражения.Найти(СледующийТокен()) <> Неопределено Тогда
		Выражение = РазобратьВыражение();
	КонецЕсли;
	Узел = Парсер_Узлы.ОператорВызватьИсключение.Добавить();
	Узел.Type = Типы.ОператорВызватьИсключение;
	Узел.Выражение = Выражение;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорВыполнить()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорВыполнить.Добавить();
	Узел.Type = Типы.ОператорВыполнить;
	Узел.Выражение = РазобратьВыражение();
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорПрисваиванияИлиВызоваПроцедуры()
	Перем ЛевыйОперанд, ЭтоВызов, ПравыйОперанд, Оператор, НоваяПеременная, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	ЛевыйОперанд = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, ЭтоВызов);
	Если ЭтоВызов Тогда
		Оператор = Парсер_Узлы.ОператорВызоваПроцедуры.Добавить();
		Оператор.Type = Типы.ОператорВызоваПроцедуры;
		Оператор.Идентификатор = ЛевыйОперанд;
		Оператор.Start = Start;
		Оператор.Конец = Парсер_ДанныеПредыдущегоТокена;
	Иначе
		Ожидать(Токены.ЗнакРавно);
		СледующийТокен();
		ПравыйОперанд = РазобратьВыражение();
		Если НоваяПеременная <> Неопределено Тогда
			Парсер_Переменные.Вставить(НоваяПеременная.Name, НоваяПеременная);
			Парсер_Окружение.АвтоПеременные.Добавить(НоваяПеременная.Объявление);
		КонецЕсли;
		Оператор = Парсер_Узлы.ОператорПрисваивания.Добавить();
		Оператор.Type = Типы.ОператорПрисваивания;
		Оператор.ЛевыйОперанд = ЛевыйОперанд;
		Оператор.ПравыйОперанд = ПравыйОперанд;
		Оператор.Start = Start;
		Оператор.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЕсли;
	Возврат Оператор;
КонецФункции 

Функция РазобратьОператорЕсли()
	Перем Выражение, ТогдаОператоры, ОператорИначе, СписокИначеЕсли, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.Тогда);
	СледующийТокен();
	ТогдаОператоры = РазобратьОператоры();
	Если Парсер_Токен = Токены.ИначеЕсли Тогда
		СписокИначеЕсли = Новый Массив;
		Пока Парсер_Токен = Токены.ИначеЕсли Цикл
			СписокИначеЕсли.Добавить(РазобратьОператорИначеЕсли());
		КонецЦикла;
	КонецЕсли;
	Если Парсер_Токен = Токены.Иначе Тогда
		ОператорИначе = РазобратьОператорИначе();
	КонецЕсли;
	Ожидать(Токены.КонецЕсли);
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорЕсли.Добавить();
	Узел.Type = Типы.ОператорЕсли;
	Узел.Выражение = Выражение;
	Узел.Тогда = ТогдаОператоры;
	Узел.ИначеЕсли = СписокИначеЕсли;
	Узел.Иначе = ОператорИначе;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорИначеЕсли()
	Перем ЕслиВыражение, ТогдаОператоры, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	ЕслиВыражение = РазобратьВыражение();
	Ожидать(Токены.Тогда);
	СледующийТокен();
	ТогдаОператоры = РазобратьОператоры();
	Узел = Парсер_Узлы.ОператорИначеЕсли.Добавить();
	Узел.Type = Типы.ОператорИначеЕсли;
	Узел.Выражение = ЕслиВыражение;
	Узел.Тогда = ТогдаОператоры;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорИначе()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорИначе.Добавить();
	Узел.Type = Типы.ОператорИначе;
	Узел.Операторы = РазобратьОператоры();
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорПопытка()
	Перем Операторы, ОператорИсключение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.Исключение);
	ОператорИсключение = РазобратьОператорИсключение();
	Ожидать(Токены.КонецПопытки);
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорПопытка.Добавить();
	Узел.Type = Типы.ОператорПопытка;
	Узел.Попытка = Операторы;
	Узел.Исключение = ОператорИсключение;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорИсключение()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорИсключение.Добавить();
	Узел.Type = Типы.ОператорИсключение;
	Узел.Операторы = РазобратьОператоры();
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции

Функция РазобратьОператорПока()
	Перем Выражение, Операторы, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.Цикл);
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.КонецЦикла);
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорПока.Добавить();
	Узел.Type = Типы.ОператорПока;
	Узел.Выражение = Выражение;
	Узел.Операторы = Операторы;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорДля()
	Перем ВыражениеИдентификатор, ЭтоВызов, Start, Операторы, ИндексТокенаПеременной, НоваяПеременная, Старт, Финиш;
	Start = Парсер_ДанныеПредыдущегоТокена;
	Ожидать(Токены.Идентификатор);
	ИндексТокенаПеременной = Парсер_ДанныеТекущегоТокена;
	ВыражениеИдентификатор = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка(14, Неопределено, Истина, ИндексТокенаПеременной);
	КонецЕсли;
	Ожидать(Токены.ЗнакРавно);
	СледующийТокен();
	Старт = РазобратьВыражение();
	Ожидать(Токены.По);
	СледующийТокен();
	Финиш = РазобратьВыражение();
	Если НоваяПеременная <> Неопределено Тогда
		Парсер_Переменные.Вставить(НоваяПеременная.Name, НоваяПеременная);
		Парсер_Окружение.АвтоПеременные.Добавить(НоваяПеременная.Объявление);
	КонецЕсли;
	Ожидать(Токены.Цикл);
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.КонецЦикла);
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорДля.Добавить();
	Узел.Type = Типы.ОператорДля;
	Узел.Идентификатор = ВыражениеИдентификатор;
	Узел.Старт = Старт;
	Узел.Финиш = Финиш;
	Узел.Операторы = Операторы;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорДляКаждого()
	Перем ВыражениеИдентификатор, ЭтоВызов, Коллекция, Операторы, ИндексТокенаПеременной, НоваяПеременная, Start;
	Start = Парсер_ДанныеПредыдущегоТокена;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	ИндексТокенаПеременной = Парсер_ДанныеТекущегоТокена;
	ВыражениеИдентификатор = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка(14, Неопределено, Истина, ИндексТокенаПеременной);
	КонецЕсли;
	Ожидать(Токены.Из);
	СледующийТокен();
	Коллекция = РазобратьВыражение();
	Если НоваяПеременная <> Неопределено Тогда
		Парсер_Переменные.Вставить(НоваяПеременная.Name, НоваяПеременная);
		Парсер_Окружение.АвтоПеременные.Добавить(НоваяПеременная.Объявление);
	КонецЕсли;
	Ожидать(Токены.Цикл);
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.КонецЦикла);
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорДляКаждого.Добавить();
	Узел.Type = Типы.ОператорДляКаждого;
	Узел.Идентификатор = ВыражениеИдентификатор;
	Узел.Коллекция = Коллекция;
	Узел.Операторы = Операторы;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорПерейти()
	Перем Метка, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Ожидать(Токены.Метка);
	Метка = Парсер_Литерал;
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорПерейти.Добавить();
	Узел.Type = Типы.ОператорПерейти;
	Узел.Метка = Метка;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорВозврат()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Если Парсер_ЭтоФункция Тогда
		Выражение = РазобратьВыражение();
	КонецЕсли;
	Узел = Парсер_Узлы.ОператорВозврат.Добавить();
	Узел.Type = Типы.ОператорВозврат;
	Узел.Выражение = Выражение;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорПрервать()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорПрервать.Добавить();
	Узел.Type = Типы.ОператорПрервать;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорПродолжить()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Узел = Парсер_Узлы.ОператорПродолжить.Добавить();
	Узел.Type = Типы.ОператорПродолжить;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорМетка()
	Перем Метка, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Метка = Парсер_Литерал;
	СледующийТокен();
	Ожидать(Токены.Двоеточие);
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ОператорМетка.Добавить();
	Узел.Type = Типы.ОператорМетка;
	Узел.Метка = Метка;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорДобавитьОбработчик()
	Перем Событие, ОбработчикСобытия, ЭтоВызов, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Событие = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка(15, Неопределено, Истина, Start);
	КонецЕсли;
	Ожидать(Токены.Запятая);
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	ОбработчикСобытия = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка(16, Неопределено, Истина, Start);
	КонецЕсли;
	Узел = Парсер_Узлы.ОператорДобавитьОбработчик.Добавить();
	Узел.Type = Типы.ОператорДобавитьОбработчик;
	Узел.Событие = Событие;
	Узел.ОбработчикСобытия = ОбработчикСобытия;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьОператорУдалитьОбработчик()
	Перем Событие, ОбработчикСобытия, ЭтоВызов, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Событие = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка(15, Неопределено, Истина, Start);
	КонецЕсли;
	Ожидать(Токены.Запятая);
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	ОбработчикСобытия = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка(16, Неопределено, Истина, Start);
	КонецЕсли;
	Узел = Парсер_Узлы.ОператорУдалитьОбработчик.Добавить();
	Узел.Type = Типы.ОператорУдалитьОбработчик;
	Узел.Событие = Событие;
	Узел.ОбработчикСобытия = ОбработчикСобытия;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

#КонецОбласти 

#Область РазборПрепроцессора

Функция РазобратьВыражениеПрепроцессора()
	Перем Выражение, Операция, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Выражение = РазобратьВыражениеПрепроцессораИ();
	Пока Парсер_Токен = Токены.Или Цикл
		Операция = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
		ЛевыйОперанд = Выражение;
		Выражение = Парсер_Узлы.ВыражениеПрепроцессораБинарное.Добавить();
		Выражение.Type = Типы.ВыражениеПрепроцессораБинарное;
		Выражение.ЛевыйОперанд = ЛевыйОперанд;
		Выражение.Операция = Операция;
		Выражение.ПравыйОперанд = РазобратьВыражениеПрепроцессораИ();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЦикла;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеПрепроцессораИ()
	Перем Выражение, Операция, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Выражение = РазобратьВыражениеПрепроцессораНе();
	Пока Парсер_Токен = Токены.И Цикл
		Операция = Парсер_ДанныеТекущегоТокена;
		СледующийТокен();
		ЛевыйОперанд = Выражение;
		Выражение = Парсер_Узлы.ВыражениеПрепроцессораБинарное.Добавить();
		Выражение.Type = Типы.ВыражениеПрепроцессораБинарное;
		Выражение.ЛевыйОперанд = ЛевыйОперанд;
		Выражение.Операция = Операция;
		Выражение.ПравыйОперанд = РазобратьВыражениеПрепроцессораНе();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	КонецЦикла;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеПрепроцессораНе()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Если Парсер_Токен = Токены.Не Тогда
		СледующийТокен();
		Выражение = Парсер_Узлы.ВыражениеПрепроцессораНе.Добавить();
		Выражение.Type = Типы.ВыражениеПрепроцессораНе;
		Выражение.Выражение = РазобратьВыражениеПрепроцессораОперанд();
		Выражение.Start = Start;
		Выражение.Конец = Парсер_ДанныеПредыдущегоТокена;
	Иначе
		Выражение = РазобратьВыражениеПрепроцессораОперанд();
	КонецЕсли;
	Возврат Выражение;
КонецФункции 

Функция РазобратьВыражениеПрепроцессораОперанд()
	Перем Операнд;
	Если Парсер_Токен = Токены.Идентификатор Тогда
		Операнд = РазобратьВыражениеПрепроцессораСимвол();
	ИначеЕсли Парсер_Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Операнд = РазобратьВыражениеПрепроцессораСкобочное();
	Иначе
		Ошибка(7, Неопределено, Истина, Парсер_ДанныеТекущегоТокена);
	КонецЕсли;
	Возврат Операнд;
КонецФункции

Функция РазобратьВыражениеПрепроцессораСимвол()
	Перем Символ, СимволСуществует;
	СимволСуществует = СимволыПрепроцессора.Свойство(Парсер_Литерал);
	Символ = Парсер_Узлы.ВыражениеПрепроцессораСимвол.Добавить();
	Символ.Type = Типы.ВыражениеПрепроцессораСимвол;
	Символ.Символ = Парсер_Литерал;
	Символ.Существует = СимволСуществует;
	Символ.Start = Парсер_ДанныеТекущегоТокена;
	Символ.Конец = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Возврат Символ;
КонецФункции 

Функция РазобратьВыражениеПрепроцессораСкобочное()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Выражение = РазобратьВыражениеПрепроцессора();
	Ожидать(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Узел = Парсер_Узлы.ВыражениеПрепроцессораСкобочное.Добавить();
	Узел.Type = Типы.ВыражениеПрепроцессораСкобочное;
	Узел.Выражение = Выражение;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораЕсли()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Выражение = РазобратьВыражениеПрепроцессора();
	Ожидать(Токены.Тогда);
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораЕсли.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораЕсли;
	Узел.Выражение = Выражение;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораИначеЕсли()
	Перем Выражение, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Выражение = РазобратьВыражениеПрепроцессора();
	Ожидать(Токены.Тогда);
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораИначеЕсли.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораИначеЕсли;
	Узел.Выражение = Выражение;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеПредыдущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораИначе()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораИначе.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораИначе;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораКонецЕсли()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораКонецЕсли.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораКонецЕсли;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораОбласть()
	Перем Name, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Name = Парсер_Литерал;
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.InstructionPreprocessorRegion.Добавить();
	Узел.Type = Типы.InstructionPreprocessorRegion;
	Узел.Name = Name;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораКонецОбласти()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораКонецОбласти.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораКонецОбласти;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораВставка()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Парсер_Токен = Токены.ТочкаСЗапятой;
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораВставка.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораВставка;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораКонецВставки()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Парсер_Токен = Токены.ТочкаСЗапятой;
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораКонецВставки.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораКонецВставки;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораУдаление()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораУдаление.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораУдаление;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

Функция РазобратьИнструкциюПрепроцессораКонецУдаления()
	Перем Start;
	Start = Парсер_ДанныеТекущегоТокена;
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораКонецУдаления.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораКонецУдаления;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции

Функция РазобратьИнструкциюПрепроцессораИспользовать()
	Перем Путь, Start;
	Start = Парсер_ДанныеТекущегоТокена;
	СледующийТокен();
	Если Парсер_НомерТекущейСтроки <> Start.LineNumber Тогда
		Ошибка(20, Неопределено, Истина, Парсер_ДанныеТекущегоТокена);
	КонецЕсли;
	Если Парсер_Токен = Токены.Число Тогда
		Путь = Парсер_Литерал;
		Если КартаБуквЦифр[Парсер_Символ] = Буква Тогда
			СледующийТокен();
			Путь = Путь + Парсер_Литерал;
		КонецЕсли;
	ИначеЕсли Парсер_Токен = Токены.Идентификатор
		Или Парсер_Токен = Токены.Строка Тогда
		Путь = Парсер_Литерал;
	Иначе
		Ошибка(20, Неопределено, Истина, Парсер_ДанныеТекущегоТокена);
	КонецЕсли;	
	Парсер_Токен = Токены.ТочкаСЗапятой; 
	Узел = Парсер_Узлы.ИнструкцияПрепроцессораИспользовать.Добавить();
	Узел.Type = Типы.ИнструкцияПрепроцессораИспользовать;
	Узел.Путь = Путь;
	Узел.Start = Start;
	Узел.Конец = Парсер_ДанныеТекущегоТокена;
	Возврат Узел;
КонецФункции 

#КонецОбласти 

#КонецОбласти 

#Область СлужебныеМетоды

Функция Доступность(Клиент, ВнешнееСоединение, МобильноеПриложение, МобильныйКлиент, МобильныйСервер, Сервер, ТолстыйКлиент, ТонкийКлиент, ВебКлиент, Интеграция) Экспорт
	Возврат Новый Структура(
		"Клиент, ВнешнееСоединение, МобильноеПриложение, МобильныйКлиент, МобильныйСервер, Сервер, ТолстыйКлиент, ТонкийКлиент, ВебКлиент, Интеграция",
		Клиент, ВнешнееСоединение, МобильноеПриложение, МобильныйКлиент, МобильныйСервер, Сервер, ТолстыйКлиент, ТонкийКлиент, ВебКлиент, Интеграция
	);
КонецФункции

Функция КакДата(ЛитералДаты)
	Перем Список, Символ, Позиция, ДатаСтрокой, Дата;
	Список = Новый Массив;
	Для Позиция = 1 По СтрДлина(ЛитералДаты) Цикл
		Символ = Сред(ЛитералДаты, Позиция, 1);
		Если КартаБуквЦифр[Символ] = Цифра Тогда
			Список.Добавить(Символ);
		КонецЕсли;
	КонецЦикла;
	ДатаСтрокой = СтрСоединить(Список);
	Если ДатаСтрокой = "00000000"
	Или ДатаСтрокой = "000000000000"
	Или ДатаСтрокой = "00000000000000" Тогда
		Возврат '00010101';
	КонецЕсли;
	Попытка
		Дата = Дата(ДатаСтрокой);
	Исключение
		Ошибка(18, ЛитералДаты, Истина);
	КонецПопытки;
	Возврат Дата;
КонецФункции

Процедура Ожидать(Токен)
	Если Парсер_Токен <> Токен Тогда
		Ошибка(1, Токен, Истина, Парсер_ДанныеТекущегоТокена);
	КонецЕсли;
КонецПроцедуры

Процедура Ошибка(Код, Аргумент, Остановить, Start = Неопределено, Конец = Неопределено)
	Перем Ошибка, ТокенНачала, ТокенКонца;
	Ошибка = Парсер_Ошибки.Добавить();
	Ошибка.Источник = "ПарсерВстроенногоЯзыка";
	Ошибка.Код = Код;
	Ошибка.Текст = Ошибки[Код] + ?(Аргумент = Неопределено, "", ": " + Аргумент);
	Если Start = Неопределено Тогда
		ТокенНачала = Новый Структура;
		ТокенНачала.Вставить("Токен", Неопределено);
		ТокенНачала.Вставить("LineNumber", Парсер_НомерТекущейСтроки);
		ТокенНачала.Вставить("НомерКолонки", Парсер_ПозицияНачалаТокена - Парсер_ПозицияТекущейСтроки);
		ТокенНачала.Вставить("Позиция", Парсер_ПозицияНачалаТокена);
		ТокенНачала.Вставить("Длина", Парсер_ТекущаяПозиция - Парсер_ПозицияНачалаТокена);
	Иначе
		ТокенНачала = Start;
	КонецЕсли;
	Если Конец = Неопределено Тогда
		ТокенКонца = ТокенНачала;
	Иначе
		ТокенКонца = Конец;
	КонецЕсли;
	Ошибка.ПозицияНачала = Мин(ТокенНачала.Позиция, Парсер_ДлинаИсходника);
	Ошибка.НомерСтрокиНачала = ТокенНачала.LineNumber;
	Ошибка.НомерКолонкиНачала = ТокенНачала.НомерКолонки;
	Ошибка.ПозицияКонца = Мин(ТокенКонца.Позиция + ТокенКонца.Длина, Парсер_ДлинаИсходника + 1);
	Ошибка.НомерСтрокиКонца = ТокенКонца.LineNumber;
	Ошибка.НомерКолонкиКонца = ТокенКонца.НомерКолонки;
	Если Остановить Тогда
		ВызватьИсключение Ошибка.Текст;
	КонецЕсли;
КонецПроцедуры 

#КонецОбласти

#Область Посетитель

Процедура Подключить(Знач Плагины) Экспорт
	Перем Плагин, Список, ИмяПроцедуры;
	Если ТипЗнч(Плагины) <> Type("Массив") Тогда
		Плагин = Плагины;
		Плагины = Новый Массив;
		Плагины.Добавить(Плагин);
	КонецЕсли;
	Посетитель_Плагины = Плагины;
	Посетитель_Подписки = Подписки();
	Для Каждого Плагин Из Плагины Цикл
		Список = Неопределено;
		Для Каждого ИмяПроцедуры Из Плагин.Подписки() Цикл
			Если Посетитель_Подписки.Свойство(ИмяПроцедуры, Список) Тогда
				Список.Добавить(Плагин);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры 

Функция Стек() Экспорт
	Возврат Посетитель_Стек;
КонецФункции

Функция Счетчики() Экспорт
	Возврат Посетитель_Счетчики;
КонецФункции

Процедура ДобавитьНаСтек(Узел)
	Посетитель_Стек.Добавить(Узел);
	Посетитель_Счетчики[Узел.Type] = Посетитель_Счетчики[Узел.Type] + 1;
КонецПроцедуры 

Процедура УдалитьСоСтека()
	Перем Узел, Вершина;
	Вершина = Посетитель_Стек.ВГраница();
	Узел = Посетитель_Стек[Вершина];
	Посетитель_Счетчики[Узел.Type] = Посетитель_Счетчики[Узел.Type] - 1;
	Посетитель_Стек.Удалить(Вершина);
КонецПроцедуры 

Функция Подписки()
	Перем Подписки, Элемент;

	Подписки = Новый Структура(
		"ПосетитьМодуль,                              ПокинутьМодуль,"
		"ПосетитьОбъявления,                          ПокинутьОбъявления,"
		"ПосетитьОператоры,                           ПокинутьОператоры,"
		"ПосетитьОбъявлениеСпискаПеременныхМодуля,    ПокинутьОбъявлениеСпискаПеременныхМодуля,"
		"ПосетитьОбъявлениеПеременнойМодуля,          ПокинутьОбъявлениеПеременнойМодуля,"
		"ПосетитьОбъявлениеСпискаЛокальныхПеременных, ПокинутьОбъявлениеСпискаЛокальныхПеременных,"
		"ПосетитьОбъявлениеЛокальнойПеременной,       ПокинутьОбъявлениеЛокальнойПеременной,"
		"ПосетитьОбъявлениеПараметра,                 ПокинутьОбъявлениеПараметра,"
		"ПосетитьОбъявлениеМетода,                    ПокинутьОбъявлениеМетода,"
		"ПосетитьСигнатуру,                           ПокинутьСигнатуру,"
		"ПосетитьВыражение,                           ПокинутьВыражение,"          
		"ПосетитьВыражениеЛитерал,                    ПокинутьВыражениеЛитерал,"
		"ПосетитьВыражениеИдентификатор,              ПокинутьВыражениеИдентификатор,"
		"ПосетитьВыражениеУнарное,                    ПокинутьВыражениеУнарное,"
		"ПосетитьВыражениеБинарное,                   ПокинутьВыражениеБинарное,"
		"ПосетитьВыражениеНовый,                      ПокинутьВыражениеНовый,"
		"ПосетитьВыражениеТернарное,                  ПокинутьВыражениеТернарное,"
		"ПосетитьВыражениеСкобочное,                  ПокинутьВыражениеСкобочное,"
		"ПосетитьВыражениеНе,                         ПокинутьВыражениеНе,"
		"ПосетитьВыражениеСтроковое,                  ПокинутьВыражениеСтроковое,"
		"ПосетитьОператорПрисваивания,                ПокинутьОператорПрисваивания,"
		"ПосетитьОператорВозврат,                     ПокинутьОператорВозврат,"
		"ПосетитьОператорПрервать,                    ПокинутьОператорПрервать,"
		"ПосетитьОператорПродолжить,                  ПокинутьОператорПродолжить,"
		"ПосетитьОператорВызватьИсключение,           ПокинутьОператорВызватьИсключение,"
		"ПосетитьОператорВыполнить,                   ПокинутьОператорВыполнить,"
		"ПосетитьОператорВызоваПроцедуры,             ПокинутьОператорВызоваПроцедуры,"
		"ПосетитьОператорЕсли,                        ПокинутьОператорЕсли,"
		"ПосетитьОператорИначеЕсли,                   ПокинутьОператорИначеЕсли,"
		"ПосетитьОператорИначе,                       ПокинутьОператорИначе,"
		"ПосетитьОператорПока,                        ПокинутьОператорПока,"
		"ПосетитьОператорДля,                         ПокинутьОператорДля,"
		"ПосетитьОператорДляКаждого,                  ПокинутьОператорДляКаждого,"
		"ПосетитьОператорПопытка,                     ПокинутьОператорПопытка,"
		"ПосетитьОператорИсключение,                  ПокинутьОператорИсключение,"
		"ПосетитьОператорПерейти,                     ПокинутьОператорПерейти,"
		"ПосетитьОператорМетка,                       ПокинутьОператорМетка,"
		"ПосетитьОператорДобавитьОбработчик,          ПокинутьОператорДобавитьОбработчик,"
		"ПосетитьОператорУдалитьОбработчик,           ПокинутьОператорУдалитьОбработчик,"
		"ПосетитьИнструкциюПрепроцессора,             ПокинутьИнструкциюПрепроцессора,"
		"ПосетитьВыражениеПрепроцессора,              ПокинутьВыражениеПрепроцессора,"
		"ПосетитьВыражениеПрепроцессораБинарное,      ПокинутьВыражениеПрепроцессораБинарное,"
		"ПосетитьВыражениеПрепроцессораНе,            ПокинутьВыражениеПрепроцессораНе,"
		"ПосетитьВыражениеПрепроцессораСимвол,        ПокинутьВыражениеПрепроцессораСимвол,"
		"ПосетитьВыражениеПрепроцессораСкобочное,     ПокинутьВыражениеПрепроцессораСкобочное"
	);

	Для Каждого Элемент Из Подписки Цикл
		Подписки[Элемент.Ключ] = Новый Массив;
	КонецЦикла;

	Возврат Подписки;
КонецФункции

Процедура Посетить(Модуль, Parameters = Неопределено) Экспорт
	Перем Плагин, Подписка, Элемент, ПараметрыПлагина;
	Если Parameters = Неопределено Тогда
		Parameters = Новый Соответствие;
	КонецЕсли;
	Посетитель_Стек = Новый Массив;
	Посетитель_Счетчики = Новый Структура;
	Для Каждого Элемент Из Типы Цикл
		Посетитель_Счетчики.Вставить(Элемент.Ключ, 0);
	КонецЦикла;
	Для Каждого Плагин Из Посетитель_Плагины Цикл
		Попытка
			ПараметрыПлагина = Parameters[Плагин.ЭтотОбъект];
		Исключение
			ПараметрыПлагина = Parameters[Плагин];
		КонецПопытки;
		Плагин.Открыть(ЭтотОбъект, ПараметрыПлагина);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьМодуль Цикл
		Подписка.ПосетитьМодуль(Модуль);
	КонецЦикла;
	ДобавитьНаСтек(Модуль);
	ПосетитьОбъявления(Модуль.Declarations);
	ПосетитьОператоры(Модуль.Операторы);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьМодуль Цикл
		Подписка.ПокинутьМодуль(Модуль);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОбъявления(Declarations)
	Перем Объявление, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявления Цикл
		Подписка.ПосетитьОбъявления(Declarations);
	КонецЦикла;
	Для Каждого Объявление Из Declarations Цикл
		ПосетитьОбъявлениеПоТипу(Объявление);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявления Цикл
		Подписка.ПокинутьОбъявления(Declarations);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьОператоры(Операторы)
	Перем Оператор, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператоры Цикл
		Подписка.ПосетитьОператоры(Операторы);
	КонецЦикла;
	Для Каждого Оператор Из Операторы Цикл
		ПосетитьОператорПоТипу(Оператор);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператоры Цикл
		Подписка.ПокинутьОператоры(Операторы);
	КонецЦикла;
КонецПроцедуры

#Область ПосещениеОбъявлений

Процедура ПосетитьОбъявлениеПоТипу(Объявление)
	Перем Type;
	Type = Объявление.Type;
	Если Type = Типы.ОбъявлениеСпискаПеременныхМодуля Тогда
		ПосетитьОбъявлениеСпискаПеременныхМодуля(Объявление);
	ИначеЕсли Type = Типы.ОбъявлениеЛокальнойПеременной Тогда
		ПосетитьОбъявлениеЛокальнойПеременной(Объявление);
	ИначеЕсли Type = Типы.MethodDeclaration Тогда
		ПосетитьОбъявлениеМетода(Объявление);
	ИначеЕсли Type = Типы.InstructionPreprocessorRegion
		Или Type = Типы.ИнструкцияПрепроцессораКонецОбласти
		Или Type = Типы.ИнструкцияПрепроцессораЕсли
		Или Type = Типы.ИнструкцияПрепроцессораИначеЕсли
		Или Type = Типы.ИнструкцияПрепроцессораИначе
		Или Type = Типы.ИнструкцияПрепроцессораКонецЕсли
		Или Type = Типы.ИнструкцияПрепроцессораИспользовать Тогда
		ПосетитьИнструкциюПрепроцессора(Объявление);
	КонецЕсли;
КонецПроцедуры 

Процедура ПосетитьОбъявлениеСпискаПеременныхМодуля(ОбъявлениеСпискаПеременныхМодуля)
	Перем Подписка, ОбъявлениеПеременнойМодуля;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеСпискаПеременныхМодуля Цикл
		Подписка.ПосетитьОбъявлениеСпискаПеременныхМодуля(ОбъявлениеСпискаПеременныхМодуля);
	КонецЦикла;
	ДобавитьНаСтек(ОбъявлениеСпискаПеременныхМодуля);
	Для Каждого ОбъявлениеПеременнойМодуля Из ОбъявлениеСпискаПеременныхМодуля.Declarations Цикл
		ПосетитьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля);
	КонецЦикла;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеСпискаПеременныхМодуля Цикл
		Подписка.ПокинутьОбъявлениеСпискаПеременныхМодуля(ОбъявлениеСпискаПеременныхМодуля);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеПеременнойМодуля Цикл
		Подписка.ПосетитьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеПеременнойМодуля Цикл
		Подписка.ПокинутьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьОбъявлениеСпискаЛокальныхПеременных(ОбъявлениеСпискаЛокальныхПеременных)
	Перем Подписка, ОбъявлениеЛокальнойПеременной;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеСпискаЛокальныхПеременных Цикл
		Подписка.ПосетитьОбъявлениеСпискаЛокальныхПеременных(ОбъявлениеСпискаЛокальныхПеременных);
	КонецЦикла;
	ДобавитьНаСтек(ОбъявлениеСпискаЛокальныхПеременных);
	Для Каждого ОбъявлениеЛокальнойПеременной Из ОбъявлениеСпискаЛокальныхПеременных.Declarations Цикл
		ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной);
	КонецЦикла;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеСпискаЛокальныхПеременных Цикл
		Подписка.ПокинутьОбъявлениеСпискаЛокальныхПеременных(ОбъявлениеСпискаЛокальныхПеременных);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеЛокальнойПеременной Цикл
		Подписка.ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеЛокальнойПеременной Цикл
		Подписка.ПокинутьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеПараметра Цикл
		Подписка.ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеПараметра Цикл
		Подписка.ПокинутьОбъявлениеПараметра(ОбъявлениеПараметра);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОбъявлениеМетода(MethodDeclaration)
	Перем Подписка, ОбъявлениеСпискаЛокальныхПеременных;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеМетода Цикл
		Подписка.ПосетитьОбъявлениеМетода(MethodDeclaration);
	КонецЦикла;
	ДобавитьНаСтек(MethodDeclaration);
	ПосетитьСигнатуру(MethodDeclaration.Signature);
	Для Каждого ОбъявлениеСпискаЛокальныхПеременных Из MethodDeclaration.Declarations Цикл
		ПосетитьОбъявлениеСпискаЛокальныхПеременных(ОбъявлениеСпискаЛокальныхПеременных);
	КонецЦикла;
	ПосетитьОператоры(MethodDeclaration.Операторы);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеМетода Цикл
		Подписка.ПокинутьОбъявлениеМетода(MethodDeclaration);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьСигнатуру(Signature)
	Перем Подписка, ОбъявлениеПараметра;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьСигнатуру Цикл
		Подписка.ПосетитьСигнатуру(Signature);
	КонецЦикла;
	ДобавитьНаСтек(Signature);
	Для Каждого ОбъявлениеПараметра Из Signature.Parameters Цикл
		ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра);
	КонецЦикла;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьСигнатуру Цикл
		Подписка.ПокинутьСигнатуру(Signature);
	КонецЦикла;
КонецПроцедуры 

#КонецОбласти

#Область ПосещениеВыражений

Процедура ПосетитьВыражение(Выражение)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражение Цикл
		Подписка.ПосетитьВыражение(Выражение);
	КонецЦикла;
	ПосетитьВыражениеПоТипу(Выражение);
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражение Цикл
		Подписка.ПокинутьВыражение(Выражение);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеПоТипу(Выражение)
	Перем Type;
	Type = Выражение.Type;
	Если Type = Типы.ВыражениеЛитерал Тогда
		ПосетитьВыражениеЛитерал(Выражение);
	ИначеЕсли Type = Типы.ВыражениеИдентификатор Тогда
		ПосетитьВыражениеИдентификатор(Выражение);
	ИначеЕсли Type = Типы.ВыражениеУнарное Тогда
		ПосетитьВыражениеУнарное(Выражение);
	ИначеЕсли Type = Типы.ВыражениеБинарное Тогда
		ПосетитьВыражениеБинарное(Выражение);
	ИначеЕсли Type = Типы.ВыражениеНовый Тогда
		ПосетитьВыражениеНовый(Выражение);
	ИначеЕсли Type = Типы.ВыражениеТернарное Тогда
		ПосетитьВыражениеТернарное(Выражение);
	ИначеЕсли Type = Типы.ВыражениеСкобочное Тогда
		ПосетитьВыражениеСкобочное(Выражение);
	ИначеЕсли Type = Типы.ВыражениеНе Тогда
		ПосетитьВыражениеНе(Выражение);
	ИначеЕсли Type = Типы.ВыражениеСтроковое Тогда
		ПосетитьВыражениеСтроковое(Выражение);
	КонецЕсли;
КонецПроцедуры

Процедура ПосетитьВыражениеЛитерал(ВыражениеЛитерал)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеЛитерал Цикл
		Подписка.ПосетитьВыражениеЛитерал(ВыражениеЛитерал);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеЛитерал Цикл
		Подписка.ПокинутьВыражениеЛитерал(ВыражениеЛитерал);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеИдентификатор(ВыражениеИдентификатор)
	Перем Элемент, Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеИдентификатор Цикл
		Подписка.ПосетитьВыражениеИдентификатор(ВыражениеИдентификатор);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеИдентификатор);
	Если ВыражениеИдентификатор.Аргументы <> Неопределено Тогда
		Для Каждого Выражение Из ВыражениеИдентификатор.Аргументы Цикл
			Если Выражение <> Неопределено Тогда
				ПосетитьВыражениеПоТипу(Выражение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Для Каждого Элемент Из ВыражениеИдентификатор.Хвост Цикл
		Если Элемент.Type = Типы.ВыражениеПоле Тогда
			Если Элемент.Аргументы <> Неопределено Тогда
				Для Каждого Выражение Из Элемент.Аргументы Цикл
					Если Выражение <> Неопределено Тогда
						ПосетитьВыражениеПоТипу(Выражение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Элемент.Type = Типы.ВыражениеИндекс Тогда
			ПосетитьВыражениеПоТипу(Элемент.Выражение);
		Иначе
			ВызватьИсключение "нарушение протокола";
		КонецЕсли;
	КонецЦикла;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеИдентификатор Цикл
		Подписка.ПокинутьВыражениеИдентификатор(ВыражениеИдентификатор);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьВыражениеУнарное(ВыражениеУнарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеУнарное Цикл
		Подписка.ПосетитьВыражениеУнарное(ВыражениеУнарное);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеУнарное);
	ПосетитьВыражениеПоТипу(ВыражениеУнарное.Операнд);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеУнарное Цикл
		Подписка.ПокинутьВыражениеУнарное(ВыражениеУнарное);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеБинарное(ВыражениеБинарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеБинарное Цикл
		Подписка.ПосетитьВыражениеБинарное(ВыражениеБинарное);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеБинарное);
	ПосетитьВыражениеПоТипу(ВыражениеБинарное.ЛевыйОперанд);
	ПосетитьВыражениеПоТипу(ВыражениеБинарное.ПравыйОперанд);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеБинарное Цикл
		Подписка.ПокинутьВыражениеБинарное(ВыражениеБинарное);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьВыражениеНовый(ВыражениеНовый)
	Перем Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеНовый Цикл
		Подписка.ПосетитьВыражениеНовый(ВыражениеНовый);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеНовый);
	Для Каждого Выражение Из ВыражениеНовый.Аргументы Цикл
		Если Выражение <> Неопределено Тогда
			ПосетитьВыражениеПоТипу(Выражение);
		КонецЕсли;
	КонецЦикла;
	Для Каждого Элемент Из ВыражениеНовый.Хвост Цикл
		Если Элемент.Type = Типы.ВыражениеПоле Тогда
			Если Элемент.Аргументы <> Неопределено Тогда
				Для Каждого Выражение Из Элемент.Аргументы Цикл
					Если Выражение <> Неопределено Тогда
						ПосетитьВыражениеПоТипу(Выражение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Элемент.Type = Типы.ВыражениеИндекс Тогда
			ПосетитьВыражениеПоТипу(Элемент.Выражение);
		Иначе
			ВызватьИсключение "нарушение протокола";
		КонецЕсли;
	КонецЦикла;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеНовый Цикл
		Подписка.ПокинутьВыражениеНовый(ВыражениеНовый);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеТернарное(ВыражениеТернарное)
	Перем Элемент, Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеТернарное Цикл
		Подписка.ПосетитьВыражениеТернарное(ВыражениеТернарное);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеТернарное);
	ПосетитьВыражениеПоТипу(ВыражениеТернарное.Выражение);
	ПосетитьВыражениеПоТипу(ВыражениеТернарное.Тогда);
	ПосетитьВыражениеПоТипу(ВыражениеТернарное.Иначе);
	Для Каждого Элемент Из ВыражениеТернарное.Хвост Цикл
		Если Элемент.Type = Типы.ВыражениеПоле Тогда
			Если Элемент.Аргументы <> Неопределено Тогда
				Для Каждого Выражение Из Элемент.Аргументы Цикл
					Если Выражение <> Неопределено Тогда
						ПосетитьВыражениеПоТипу(Выражение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Элемент.Type = Типы.ВыражениеИндекс Тогда
			ПосетитьВыражениеПоТипу(Элемент.Выражение);
		Иначе
			ВызватьИсключение "нарушение протокола";
		КонецЕсли;
	КонецЦикла;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеТернарное Цикл
		Подписка.ПокинутьВыражениеТернарное(ВыражениеТернарное);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеСкобочное(ВыражениеСкобочное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеСкобочное Цикл
		Подписка.ПосетитьВыражениеСкобочное(ВыражениеСкобочное);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеСкобочное);
	ПосетитьВыражениеПоТипу(ВыражениеСкобочное.Выражение);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеСкобочное Цикл
		Подписка.ПокинутьВыражениеСкобочное(ВыражениеСкобочное);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеНе(ВыражениеНе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеНе Цикл
		Подписка.ПосетитьВыражениеНе(ВыражениеНе);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеНе);
	ПосетитьВыражениеПоТипу(ВыражениеНе.Выражение);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеНе Цикл
		Подписка.ПокинутьВыражениеНе(ВыражениеНе);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьВыражениеСтроковое(ВыражениеСтроковое)
	Перем Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеСтроковое Цикл
		Подписка.ПосетитьВыражениеСтроковое(ВыражениеСтроковое);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеСтроковое);
	Для Каждого Выражение Из ВыражениеСтроковое.Items Цикл
		ПосетитьВыражениеЛитерал(Выражение);
	КонецЦикла;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеСтроковое Цикл
		Подписка.ПокинутьВыражениеСтроковое(ВыражениеСтроковое);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти

#Область ПосещениеОператоров

Процедура ПосетитьОператорПоТипу(Оператор)
	Перем Type;
	Type = Оператор.Type;
	Если Type = Типы.ОператорПрисваивания Тогда
		ПосетитьОператорПрисваивания(Оператор);
	ИначеЕсли Type = Типы.ОператорВозврат Тогда
		ПосетитьОператорВозврат(Оператор);
	ИначеЕсли Type = Типы.ОператорПрервать Тогда
		ПосетитьОператорПрервать(Оператор);
	ИначеЕсли Type = Типы.ОператорПродолжить Тогда
		ПосетитьОператорПродолжить(Оператор);
	ИначеЕсли Type = Типы.ОператорВызватьИсключение Тогда
		ПосетитьОператорВызватьИсключение(Оператор);
	ИначеЕсли Type = Типы.ОператорВыполнить Тогда
		ПосетитьОператорВыполнить(Оператор);
	ИначеЕсли Type = Типы.ОператорВызоваПроцедуры Тогда
		ПосетитьОператорВызоваПроцедуры(Оператор);
	ИначеЕсли Type = Типы.ОператорЕсли Тогда
		ПосетитьОператорЕсли(Оператор);
	ИначеЕсли Type = Типы.ОператорПока Тогда
		ПосетитьОператорПока(Оператор);
	ИначеЕсли Type = Типы.ОператорДля Тогда
		ПосетитьОператорДля(Оператор);
	ИначеЕсли Type = Типы.ОператорДляКаждого Тогда
		ПосетитьОператорДляКаждого(Оператор);
	ИначеЕсли Type = Типы.ОператорПопытка Тогда
		ПосетитьОператорПопытка(Оператор);
	ИначеЕсли Type = Типы.ОператорПерейти Тогда
		ПосетитьОператорПерейти(Оператор);
	ИначеЕсли Type = Типы.ОператорМетка Тогда
		ПосетитьОператорМетка(Оператор);
	ИначеЕсли Type = Типы.ОператорДобавитьОбработчик Тогда
		ПосетитьОператорДобавитьОбработчик(Оператор);
	ИначеЕсли Type = Типы.ОператорУдалитьОбработчик Тогда
		ПосетитьОператорУдалитьОбработчик(Оператор);
	ИначеЕсли Type = Типы.InstructionPreprocessorRegion
		Или Type = Типы.ИнструкцияПрепроцессораКонецОбласти
		Или Type = Типы.ИнструкцияПрепроцессораЕсли
		Или Type = Типы.ИнструкцияПрепроцессораИначеЕсли
		Или Type = Типы.ИнструкцияПрепроцессораИначе
		Или Type = Типы.ИнструкцияПрепроцессораКонецЕсли
		Или Type = Типы.ИнструкцияПрепроцессораВставка
		Или Type = Типы.ИнструкцияПрепроцессораКонецВставки
		Или Type = Типы.ИнструкцияПрепроцессораУдаление
		Или Type = Типы.ИнструкцияПрепроцессораКонецУдаления Тогда
		ПосетитьИнструкциюПрепроцессора(Оператор);
	КонецЕсли;
КонецПроцедуры

Процедура ПосетитьОператорПрисваивания(ОператорПрисваивания)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПрисваивания Цикл
		Подписка.ПосетитьОператорПрисваивания(ОператорПрисваивания);
	КонецЦикла;
	ДобавитьНаСтек(ОператорПрисваивания);
	ПосетитьВыражениеИдентификатор(ОператорПрисваивания.ЛевыйОперанд);
	ПосетитьВыражение(ОператорПрисваивания.ПравыйОперанд);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПрисваивания Цикл
		Подписка.ПокинутьОператорПрисваивания(ОператорПрисваивания);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорВозврат(ОператорВозврат)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВозврат Цикл
		Подписка.ПосетитьОператорВозврат(ОператорВозврат);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВозврат);
	Если ОператорВозврат.Выражение <> Неопределено Тогда
		ПосетитьВыражение(ОператорВозврат.Выражение);
	КонецЕсли;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВозврат Цикл
		Подписка.ПокинутьОператорВозврат(ОператорВозврат);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорПрервать(ОператорПрервать)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПрервать Цикл
		Подписка.ПосетитьОператорПрервать(ОператорПрервать);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПрервать Цикл
		Подписка.ПокинутьОператорПрервать(ОператорПрервать);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорПродолжить(ОператорПродолжить)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПродолжить Цикл
		Подписка.ПосетитьОператорПродолжить(ОператорПродолжить);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПродолжить Цикл
		Подписка.ПокинутьОператорПродолжить(ОператорПродолжить);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорВызватьИсключение(ОператорВызватьИсключение)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВызватьИсключение Цикл
		Подписка.ПосетитьОператорВызватьИсключение(ОператорВызватьИсключение);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВызватьИсключение);
	Если ОператорВызватьИсключение.Выражение <> Неопределено Тогда
		ПосетитьВыражение(ОператорВызватьИсключение.Выражение);
	КонецЕсли;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВызватьИсключение Цикл
		Подписка.ПокинутьОператорВызватьИсключение(ОператорВызватьИсключение);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорВыполнить(ОператорВыполнить)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВыполнить Цикл
		Подписка.ПосетитьОператорВыполнить(ОператорВыполнить);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВыполнить);
	ПосетитьВыражение(ОператорВыполнить.Выражение);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВыполнить Цикл
		Подписка.ПокинутьОператорВыполнить(ОператорВыполнить);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорВызоваПроцедуры(ОператорВызоваПроцедуры)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВызоваПроцедуры Цикл
		Подписка.ПосетитьОператорВызоваПроцедуры(ОператорВызоваПроцедуры);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВызоваПроцедуры);
	ПосетитьВыражениеИдентификатор(ОператорВызоваПроцедуры.Идентификатор);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВызоваПроцедуры Цикл
		Подписка.ПокинутьОператорВызоваПроцедуры(ОператорВызоваПроцедуры);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорЕсли(ОператорЕсли)
	Перем ОператорИначеЕсли, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорЕсли Цикл
		Подписка.ПосетитьОператорЕсли(ОператорЕсли);
	КонецЦикла;
	ДобавитьНаСтек(ОператорЕсли);
	ПосетитьВыражение(ОператорЕсли.Выражение);
	ПосетитьОператоры(ОператорЕсли.Тогда);
	Если ОператорЕсли.ИначеЕсли <> Неопределено Тогда
		Для Каждого ОператорИначеЕсли Из ОператорЕсли.ИначеЕсли Цикл
			ПосетитьОператорИначеЕсли(ОператорИначеЕсли);
		КонецЦикла;
	КонецЕсли;
	Если ОператорЕсли.Иначе <> Неопределено Тогда
		ПосетитьОператорИначе(ОператорЕсли.Иначе);
	КонецЕсли;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорЕсли Цикл
		Подписка.ПокинутьОператорЕсли(ОператорЕсли);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорИначеЕсли(ОператорИначеЕсли)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорИначеЕсли Цикл
		Подписка.ПосетитьОператорИначеЕсли(ОператорИначеЕсли);
	КонецЦикла;
	ДобавитьНаСтек(ОператорИначеЕсли);
	ПосетитьВыражение(ОператорИначеЕсли.Выражение);
	ПосетитьОператоры(ОператорИначеЕсли.Тогда);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорИначеЕсли Цикл
		Подписка.ПокинутьОператорИначеЕсли(ОператорИначеЕсли);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорИначе(ОператорИначе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорИначе Цикл
		Подписка.ПосетитьОператорИначе(ОператорИначе);
	КонецЦикла;
	ДобавитьНаСтек(ОператорИначе);
	ПосетитьОператоры(ОператорИначе.Операторы);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорИначе Цикл
		Подписка.ПокинутьОператорИначе(ОператорИначе);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорПока(ОператорПока)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПока Цикл
		Подписка.ПосетитьОператорПока(ОператорПока);
	КонецЦикла;
	ДобавитьНаСтек(ОператорПока);
	ПосетитьВыражение(ОператорПока.Выражение);
	ПосетитьОператоры(ОператорПока.Операторы);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПока Цикл
		Подписка.ПокинутьОператорПока(ОператорПока);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорДля(ОператорДля)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорДля Цикл
		Подписка.ПосетитьОператорДля(ОператорДля);
	КонецЦикла;
	ДобавитьНаСтек(ОператорДля);
	ПосетитьВыражениеИдентификатор(ОператорДля.Идентификатор);
	ПосетитьВыражение(ОператорДля.Старт);
	ПосетитьВыражение(ОператорДля.Финиш);
	ПосетитьОператоры(ОператорДля.Операторы);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорДля Цикл
		Подписка.ПокинутьОператорДля(ОператорДля);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорДляКаждого(ОператорДляКаждого)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорДляКаждого Цикл
		Подписка.ПосетитьОператорДляКаждого(ОператорДляКаждого);
	КонецЦикла;
	ДобавитьНаСтек(ОператорДляКаждого);
	ПосетитьВыражениеИдентификатор(ОператорДляКаждого.Идентификатор);
	ПосетитьВыражение(ОператорДляКаждого.Коллекция);
	ПосетитьОператоры(ОператорДляКаждого.Операторы);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорДляКаждого Цикл
		Подписка.ПокинутьОператорДляКаждого(ОператорДляКаждого);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорПопытка(ОператорПопытка)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПопытка Цикл
		Подписка.ПосетитьОператорПопытка(ОператорПопытка);
	КонецЦикла;
	ДобавитьНаСтек(ОператорПопытка);
	ПосетитьОператоры(ОператорПопытка.Попытка);
	ПосетитьОператорИсключение(ОператорПопытка.Исключение);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПопытка Цикл
		Подписка.ПокинутьОператорПопытка(ОператорПопытка);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорИсключение(ОператорИсключение)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорИсключение Цикл
		Подписка.ПосетитьОператорИсключение(ОператорИсключение);
	КонецЦикла;
	ДобавитьНаСтек(ОператорИсключение);
	ПосетитьОператоры(ОператорИсключение.Операторы);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорИсключение Цикл
		Подписка.ПокинутьОператорИсключение(ОператорИсключение);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорПерейти(ОператорПерейти)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПерейти Цикл
		Подписка.ПосетитьОператорПерейти(ОператорПерейти);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПерейти Цикл
		Подписка.ПокинутьОператорПерейти(ОператорПерейти);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорМетка(ОператорМетка)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорМетка Цикл
		Подписка.ПосетитьОператорМетка(ОператорМетка);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорМетка Цикл
		Подписка.ПокинутьОператорМетка(ОператорМетка);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорДобавитьОбработчик(ОператорДобавитьОбработчик)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорДобавитьОбработчик Цикл
		Подписка.ПосетитьОператорДобавитьОбработчик(ОператорДобавитьОбработчик);
	КонецЦикла;
	ДобавитьНаСтек(ОператорДобавитьОбработчик);
	ПосетитьВыражениеИдентификатор(ОператорДобавитьОбработчик.Событие);
	ПосетитьВыражениеИдентификатор(ОператорДобавитьОбработчик.ОбработчикСобытия);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорДобавитьОбработчик Цикл
		Подписка.ПокинутьОператорДобавитьОбработчик(ОператорДобавитьОбработчик);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьОператорУдалитьОбработчик(ОператорУдалитьОбработчик)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорУдалитьОбработчик Цикл
		Подписка.ПосетитьОператорУдалитьОбработчик(ОператорУдалитьОбработчик);
	КонецЦикла;
	ДобавитьНаСтек(ОператорУдалитьОбработчик);
	ПосетитьВыражениеИдентификатор(ОператорУдалитьОбработчик.Событие);
	ПосетитьВыражениеИдентификатор(ОператорУдалитьОбработчик.ОбработчикСобытия);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорУдалитьОбработчик Цикл
		Подписка.ПокинутьОператорУдалитьОбработчик(ОператорУдалитьОбработчик);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти

#Область ПосещениеВыраженийПрепроцессора

Процедура ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессора)
	Перем Type, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессора Цикл
		Подписка.ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессора);
	КонецЦикла;
	Type = ВыражениеПрепроцессора.Type;
	Если Type = Типы.ВыражениеПрепроцессораСимвол Тогда
		ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессора);
	ИначеЕсли Type = Типы.ВыражениеПрепроцессораБинарное Тогда
		ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессора);
	ИначеЕсли Type = Типы.ВыражениеПрепроцессораНе Тогда
		ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессора);
	ИначеЕсли Type = Типы.ВыражениеПрепроцессораСкобочное Тогда
		ПосетитьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессора);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессора Цикл
		Подписка.ПокинутьВыражениеПрепроцессора(ВыражениеПрепроцессора);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораСимвол Цикл
		Подписка.ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораСимвол Цикл
		Подписка.ПокинутьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол);
	КонецЦикла;
КонецПроцедуры

Процедура ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораБинарное Цикл
		Подписка.ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеПрепроцессораБинарное);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораБинарное.ЛевыйОперанд);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораБинарное.ПравыйОперанд);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораБинарное Цикл
		Подписка.ПокинутьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораНе Цикл
		Подписка.ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеПрепроцессораНе);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораНе.Выражение);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораНе Цикл
		Подписка.ПокинутьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессораСкобочное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораСкобочное Цикл
		Подписка.ПосетитьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессораСкобочное);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеПрепроцессораСкобочное);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораСкобочное.Выражение);
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораСкобочное Цикл
		Подписка.ПокинутьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессораСкобочное);
	КонецЦикла;
КонецПроцедуры 

Процедура ПосетитьИнструкциюПрепроцессора(ИнструкцияПрепроцессора)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПрепроцессора Цикл
		Подписка.ПосетитьИнструкциюПрепроцессора(ИнструкцияПрепроцессора);
	КонецЦикла;
	ДобавитьНаСтек(ИнструкцияПрепроцессора);
	Если ИнструкцияПрепроцессора.Владелец().Колонки.Найти("Выражение") <> Неопределено Тогда
		ПосетитьВыражениеПрепроцессора(ИнструкцияПрепроцессора.Выражение);
	КонецЕсли;
	УдалитьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьИнструкциюПрепроцессора Цикл
		Подписка.ПокинутьИнструкциюПрепроцессора(ИнструкцияПрепроцессора);
	КонецЦикла;
КонецПроцедуры 

#КонецОбласти 

#КонецОбласти 

Функция Пуск(Исходник, Знач Плагины, Parameters = Неопределено, Окружение = Неопределено) Экспорт
	Перем Результаты, Плагин;
	Подключить(Плагины);
	Посетить(Parse(Исходник, Окружение), Parameters);
	Результаты = Новый Массив;
	Для Каждого Плагин Из Посетитель_Плагины Цикл
		Результаты.Добавить(Плагин.Закрыть());
	КонецЦикла;
	Очистить();
	Возврат Результаты;
КонецФункции 

Процедура Очистить() Экспорт
	Парсер_Токены.Очистить();
	Для Каждого Элемент Из Парсер_Узлы Цикл
		Элемент.Value.ЗаполнитьЗначения(Неопределено);
		Элемент.Value.Очистить();
	КонецЦикла; 
КонецПроцедуры 

Инициализировать();


#Region Alternate



#EndRegion

#Region Alternate



#EndRegion