#Использовать oint

Перем Язык;

Процедура ПриСозданииОбъекта(Знач Язык_)

    Язык = Язык_;

КонецПроцедуры

Функция ВыполнитьТестCLI(Знач Метод, Знач Опции, Знач Записывать = Истина) Экспорт

    Если OPI_Инструменты.ЭтоWindows() Тогда

        Melezh = СтрШаблон("oscript ./src/%1/core/Classes/app.os", Язык);

    Иначе

        Melezh = "sudo melezh";

    КонецЕсли;

    ФайлРезультата = ПолучитьИмяВременногоФайла();

    СтрокаЗапуска = Melezh + " " + Метод;

    Для Каждого Опция Из Опции Цикл

        ТекущееЗначение = ПолучитьЗначениеДляCLI(Опция.Значение);

        СтрокаЗапуска = СтрокаЗапуска
            + " --"
            + Опция.Ключ
            + " "
            + ТекущееЗначение;

    КонецЦикла;

    ЗапуститьПриложение(СтрокаЗапуска + " --out """ + ФайлРезультата + """ --debug" , , Истина);

    Результат = ПрочестьРезультатCLI(ФайлРезультата);

    Если Записывать Тогда
        ЗаписатьВызовCLI(Метод, Опции);
    КонецЕсли;

    Попытка
        УдалитьФайлы(ФайлРезультата);
    Исключение
        Сообщить("Не удалось удалить временный файл после теста!");
    КонецПопытки;

    Возврат Результат;

КонецФункции

Процедура ЗаписатьЛог(Знач Результат, Знач Метод) Экспорт

    Шапка = Строка(OPI_Инструменты.ПолучитьТекущуюДату()) + " | " + Метод;

    Попытка

        Если OPI_Инструменты.ПолеКоллекцииСуществует(Результат, "path") Тогда
            Результат["path"] = "/proj.melezh";
        КонецЕсли;

        Если OPI_Инструменты.ПолеКоллекцииСуществует(Результат, "proj") Тогда
            Результат["proj"] = "/proj.melezh";
        КонецЕсли;  

        Данные = OPI_Инструменты.JSONСтрокой(Результат);
        
    Исключение
        Данные = "Не JSON: " + Строка(Результат);
    КонецПопытки;

    Данные = "    " + Данные;

    Сообщить(Шапка);
    Сообщить(Символы.ПС);
    Сообщить(Данные);
    Сообщить(Символы.ПС);
    Сообщить("---------------------------------");
    Сообщить(Символы.ПС);

	Попытка
		Библиотека = Новый ЗащищенноеСоединениеOpenSSL; // Проверка на работу в 1С
	Исключение
		ЗаписатьФайлЛога(Данные, Метод, Библиотека);
	КонецПопытки;


КонецПроцедуры

Функция ПолучитьЗначениеДляCLI(Знач Значение, Знач Вложенный = Ложь)

    ТекущийТип = ТипЗнч(Значение);

    Если ТекущийТип = Тип("Число") Тогда

        Значение = OPI_Инструменты.ЧислоВСтроку(Значение);

    ИначеЕсли ТекущийТип = Тип("Строка") Тогда

        Значение = OPI_Инструменты.ЧислоВСтроку(Значение);

        Если Не Вложенный Тогда
            Значение = """" + Значение + """";
        КонецЕсли;

    ИначеЕсли ТекущийТип = Тип("Дата") Тогда

        Значение = """" + XMLСтрока(Значение) + """";

    ИначеЕсли ТекущийТип = Тип("Структура")
        Или ТекущийТип = Тип("Соответствие")
        Или ТекущийТип = Тип("Массив") Тогда

        ЗаписьJSON = Новый ЗаписьJSON();

        Если OPI_Инструменты.ЭтоOneScript() Или ТекущийТип = Тип("Массив") Тогда

            ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, , Ложь);
            ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписи);
            ЗаписатьJSON(ЗаписьJSON, Значение);
            Значение        = """" + ЗаписьJSON.Закрыть() + """";

        Иначе

            // BSLLS:MissingTemporaryFileDeletion-off

            //@skip-check missing-temporary-file-deletion
            ИВТ   = ПолучитьИмяВременногоФайла("json");
            // BSLLS:MissingTemporaryFileDeletion-on

            Поток = Новый ФайловыйПоток(ИВТ, РежимОткрытияФайла.Создать);

            ЗаписьJSON.ОткрытьПоток(Поток);
            ЗаписатьJSON(ЗаписьJSON, Значение);
            ЗаписьJSON.Закрыть();
            Поток.Закрыть();

            Значение = ИВТ;

        КонецЕсли;

    ИначеЕсли ТекущийТип = Тип("Булево") Тогда

        Значение = ?(Значение, "true", "false");

    ИначеЕсли ТекущийТип = Тип("ДвоичныеДанные") Тогда

        // BSLLS:MissingTemporaryFileDeletion-off

        //@skip-check missing-temporary-file-deletion
        ИВФ = ПолучитьИмяВременногоФайла();
        Значение.Записать(ИВФ);
        Значение = """" + ИВФ + """";

        // BSLLS:MissingTemporaryFileDeletion-on

    Иначе

        ВызватьИсключение "Неподдерживаемый тип " + Строка(ТекущийТип);

    КонецЕсли;

    Возврат Значение;

КонецФункции

Функция ПрочестьРезультатCLI(Знач ФайлРезультата)

    Попытка

        ЧтениеJSON = Новый ЧтениеJSON();
        ЧтениеJSON.ОткрытьФайл(ФайлРезультата);
        Результат  = ПрочитатьJSON(ЧтениеJSON, Истина);
        ЧтениеJSON.Закрыть();

    Исключение

        Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

        Попытка
            Результат =  Новый ДвоичныеДанные(ФайлРезультата);
        Исключение
            Результат = null;
        КонецПопытки;

     КонецПопытки;

     Возврат Результат;

КонецФункции

Процедура ЗаписатьВызовCLI(Знач Метод, Знач Опции)

    Если Не OPI_Инструменты.ЭтоOneScript() Тогда
        Возврат;
    КонецЕсли;

    КаталогПримеров = СтрШаблон("./docs/%1/cli", Язык);
    ФайлПримеров    = Новый Файл(КаталогПримеров);

    Если Не ФайлПримеров.Существует() Тогда
        СоздатьКаталог(КаталогПримеров);
    КонецЕсли;

    КаталогМетода = КаталогПримеров + "/" + Метод;
    ФайлМетода    = Новый Файл(КаталогМетода);

    Если Не ФайлМетода.Существует() Тогда
        СоздатьКаталог(КаталогМетода);
    КонецЕсли;

    МассивОпций = Новый Массив;
    ЕстьJSON    = Ложь;

    Для Каждого Опция Из Опции Цикл

        Если ТипЗнч(Опция.Значение) = Тип("Структура")
            Или ТипЗнч(Опция.Значение) = Тип("Соответствие") Тогда

                ЕстьJSON = Истина;

        КонецЕсли;

        ТекущаяОпция = Опция.Значение;
        ТекущаяОпция = ОформитьОпцию(ТекущаяОпция, Опция.Ключ);

        МассивОпций.Добавить(ТекущаяОпция);

    КонецЦикла;

    Начало = "melezh ";

    Если ЕстьJSON Тогда

        Информация = "JSON данные также могут быть переданы как путь к файлу .json";

        НачалоBat  = ":: " + Информация + Символы.ПС + Символы.ПС + Начало;
        НачалоBash = "# " + Информация + Символы.ПС + Символы.ПС + Начало;

    Иначе

        НачалоBat  = Начало;
        НачалоBash = Начало;

    КонецЕсли;

    РазделительBat  = " ^" + Символы.ПС + "  ";
    РазделительBash = " \" + Символы.ПС + "  ";

    СтрокаBat  = НачалоBat + " " + Метод + РазделительBat + СтрСоединить(МассивОпций, РазделительBat);
    СтрокаBash = НачалоBash + " " + Метод + РазделительBash + СтрСоединить(МассивОпций, РазделительBash);

    ПолучитьДвоичныеДанныеИзСтроки(СтрокаBat).Записать(КаталогМетода + "/bat.txt");
    ПолучитьДвоичныеДанныеИзСтроки(СтрокаBash).Записать(КаталогМетода + "/bash.txt");

КонецПроцедуры

Функция ОформитьОпцию(Знач Значение, Знач Имя, Знач Вложенный = Ложь)

    МассивСекретов = Новый Массив();
    МассивСекретов.Добавить("token");
    МассивСекретов.Добавить("key");
    МассивСекретов.Добавить("secret");
    МассивСекретов.Добавить("pass");
    МассивСекретов.Добавить("client");
    МассивСекретов.Добавить("api");
    МассивСекретов.Добавить("refresh");

    СтруктураЗамен = Новый Структура;
    СтруктураЗамен.Вставить("path", "/proj.melezh");
    СтруктураЗамен.Вставить("proj", "/proj.melezh");

    Если ТипЗнч(Значение) = Тип("Структура") Или ТипЗнч(Значение) = Тип("Соответствие") Тогда

        Значение = ОформитьОпциюКоллекцию(Значение);

    ИначеЕсли ТипЗнч(Значение) = Тип("Массив") Тогда

        Значение = ОформитьОпциюМассив(Значение, Имя);

    Иначе

        Для Каждого СекретныйКлюч Из МассивСекретов Цикл

            Если СтрНайти(нРег(Имя), СекретныйКлюч) <> 0 Тогда
                Значение = "***";
            КонецЕсли;

        КонецЦикла;

        Для Каждого ЗаменяемыйКлюч Из СтруктураЗамен Цикл

            Если нРег(Имя) = ЗаменяемыйКлюч.Ключ Тогда
                Значение = ЗаменяемыйКлюч.Значение;
            КонецЕсли;

        КонецЦикла;

    КонецЕсли;

    Если Не Вложенный Тогда
        Значение = "--" + Имя + " " + ПолучитьЗначениеДляCLI(Значение);
    КонецЕсли;

    Возврат Значение;

КонецФункции

Функция ОформитьОпциюКоллекцию(Знач Значение)

    Значение_ = ?(ТипЗнч(Значение) = Тип("Структура"), Новый Структура, Новый Соответствие);

    Для Каждого Элемент Из Значение Цикл

        Значение_.Вставить(Элемент.Ключ, ОформитьОпцию(Элемент.Значение, Элемент.Ключ, Истина));

    КонецЦикла;

    Возврат Значение_;

КонецФункции

Функция ОформитьОпциюМассив(Знач Значение, Знач Имя)

    Значение_ = Новый Массив;

    Для Каждого Элемент Из Значение Цикл
        Значение_.Добавить(ОформитьОпцию(Элемент, Имя, Истина));
    КонецЦикла;

    Возврат Значение_;

КонецФункции

Процедура ЗаписатьФайлЛога(Знач Данные, Знач Метод, Знач Принудительно = Ложь) Экспорт

    Попытка

        ПутьЛогов           = СтрШаблон("./docs/%1/results", Язык);
        ПутьЛоговБиблиотеки = ПутьЛогов;

        КаталогЛогов = Новый Файл(ПутьЛогов);

        Если Не КаталогЛогов.Существует() Тогда
            СоздатьКаталог(ПутьЛогов);
        КонецЕсли;

        КаталогЛоговБиблиотеки = Новый Файл(ПутьЛоговБиблиотеки);

        Если Не КаталогЛоговБиблиотеки.Существует() Тогда
            СоздатьКаталог(ПутьЛоговБиблиотеки);
        КонецЕсли;

        ПутьКФайлу = ПутьЛоговБиблиотеки + "/" + Метод + ".log";
        ФайлЛога   = Новый Файл(ПутьКФайлу);


        ДокументЛога = Новый ТекстовыйДокумент;
        ДокументЛога.УстановитьТекст(Данные);
        ДокументЛога.Записать(ПутьКФайлу);


    Исключение
        Сообщить("Не удалось записать файл лога!: " + ОписаниеОшибки());
    КонецПопытки;

КонецПроцедуры